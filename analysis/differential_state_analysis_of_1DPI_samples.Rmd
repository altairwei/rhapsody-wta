# 1DPI 样品的差异状态分析 (Differential State analysis)

## 数据准备

`muscat` 包要求输入数据需要预先经过处理，比如整合、聚类和细胞注释等等，因此这里我们直接加载已经处理过的 `Seurat` 对象。

```{r message=FALSE, warning=FALSE}
library(magrittr)
library(patchwork)

obj <- readRDS("../results/IntegratedAnalysis/1DPI-All/Seurat_Object_Combined.rds")
```

## 数据概览

### 样本细胞降维度图

```{r warning=FALSE}
Seurat::DimPlot(obj, reduction = "tsne", group.by = "group")
Seurat::DimPlot(obj, reduction = "tsne", label = TRUE, repel = TRUE)
```

### 细胞身份注释

TODO: 从拟南芥、水稻等根部 scRNA-Seq 找维管束相关基因。

```{r fig.width=15, fig.height=8}
Seurat::DefaultAssay(obj) <- "RNA"

Seurat::DotPlot(
  obj,
  features = list(
    "FDH" = c(
      "TraesCS4B02G297500",
      "TraesCS4D02G296400",
      "TraesCS4A02G007400"
    ),
    "ATML1" = c(
      "TraesCS2A02G474000",
      "TraesCS2D02G473700"
    ),
    "DCR" = c(
      "TraesCS1A02G341300",
      "TraesCS1D02G343400"
    ),
    # EP3 是排水孔相关基因
    "EP3" = c(
      "TraesCS2A02G350700",
      "TraesCS2D02G348800",
      "TraesCS6D02G199500",
      "TraesCS6A02G216100"
    ),
    "ALMT12" = c(
      "TraesCS1D02G194000",
      "TraesCS1A02G189900",
      "TraesCS1B02G192000"
    ),
    "MYB60" = c(
      "TraesCS4A02G322200",
      "TraesCS5D02G552200"
    ),
    "HIC" = c(
      "TraesCS4D02G226100"
    ),
    "RBCS" = c(
      "TraesCS2A02G066800",
      #"TraesCS2B02G079200",
      #"TraesCS2D02G065200",
      #"TraesCS2D02G065300",
      "TraesCS5A02G165400",
      #"TraesCS5A02G165700",
      #"TraesCS5B02G162600",
      #"TraesCS5B02G162800",
      #"TraesCS5D02G169600",
      "TraesCS5D02G169900"
    ),
    "CAB3" = c(
      "TraesCS7A02G276400",
      #"TraesCS1D02G411300",
      "TraesCS1B02G317500",
      #"TraesCS7D02G276300",
      #"TraesCS5B02G353200",
      #"TraesCS5A02G350600",
      "TraesCS1A02G403300"
    ),
    "LHCB2.1" = c(
      "TraesCS5D02G329200",
      "TraesCS5B02G322900",
      "TraesCS5A02G322500"
    ),
    "CA1" = c(
      #"TraesCS7D02G443400",
      "TraesCS7B02G354800",
      "TraesCS3A02G230000",
      #"TraesCS3D02G223300",
      "TraesCS3B02G259300"
    ),
    "AOC2" = c(
      "TraesCS6D02G314300",
      "TraesCS6A02G334800",
      "TraesCS6B02G365200"
    ),
    "SULTR3;4" = c(
      "TraesCS7A02G088700",
      "TraesCS4A02G388000",
      "TraesCS7D02G084100"
    ),
    "TaGSr" = c(
      "TraesCS4B02G240900",
      "TraesCS4D02G240700",
      "TraesCS4A02G063800"
    ),
    "gl-OXO" = c(
      "TraesCS4D02G032000",
      "TraesCS4B02G033300",
      "TraesCS4A02G279200",
      "TraesCS4D02G031800"
    ),
    "TaSUT1" = c(
      "TraesCS4A02G016400",
      "TraesCS4B02G287800",
      "TraesCS4D02G286500"
    ),
    "CPIII" = c(
      "TraesCS6B02G050700",
      "TraesCS6D02G041700",
      "TraesCS6A02G036100"
    ),
    "AT1G62510" = c(
      "TraesCS2A02G424800",
      "TraesCS2B02G444500",
      #"TraesCS2D02G422700",
      #"TraesCS2D02G422800",
      "TraesCS2A02G424861"
    ),
    # Bulliform
    "PFA-DSP2" = c(
      "TraesCS5B02G163200",
      "TraesCS5D02G170400"
    )
  )
) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 90, vjust = 0.5, hjust = 1),
    strip.text.x = ggplot2::element_text(angle = 90)
  )
```

依据 marker 基因对类群重命名：

```{r}
Seurat::DefaultAssay(obj) <- "integrated"

obj <- Seurat::RenameIdents(
  obj,
  `0` = "Mesophyll Cells 4",
  `1` = "Vascular Cells 4",
  `2` = "Vascular Cells 6",
  `3` = "Mesophyll Cells 2",
  `4` = "Mesophyll Cells 3",
  `5` = "Vascular Cells 5",
  `6` = "Unknown",
  `7` = "Cortex Cells 3",
  `8` = "Cortex Cells 2",
  `9` = "Cortex Cells 1",
  `10` = "Vascular Cells 2",
  `11` = "Epidermal Cells 1",
  `12` = "Mesophyll Cells 1",
  `13` = "Epidermal Cells 2",
  `14` = "Vascular Cells 1",
  `15` = "Guardian Cells"
)

sce <- rhapsodykit::prepare_muscat_sce(obj, group_make_names = TRUE)
```


### 相对细胞群集丰度

差异状态分析依赖于细胞亚群的大小，因此群体规模太小的亚群应该事先排除掉。

```{r}
cluster_stats <- table(sce$cluster_id, sce$sample_id)
cluster_stats
```

看看各个类群在各自样本中所占的比例：

```{r warning=FALSE}
cluster_prop <- prop.table(cluster_stats, 2)
cluster_prop_df <- reshape2::melt(
  cluster_prop,
  varnames = c("cluster_id", "sample_id"),
  value.name = "frequency",
  as.is = TRUE
)

cluster_prop_df$cluster_id <- factor(type.convert(cluster_prop_df$cluster_id))
cluster_prop_df$group_id <- sce$group_id[match(cluster_prop_df$sample_id, sce$sample_id)]

p_cluster_percent <- cluster_prop_df %>%
  ggplot2::ggplot(ggplot2::aes(
    x = sample_id, y = frequency, fill = cluster_id)) +
  ggplot2::scale_y_continuous(breaks = seq(0, 1, 0.2), expand = c(0, 0)) +
  ggplot2::facet_wrap("group_id", ncol = 1, scales = "free_y") +
  ggplot2::geom_bar(stat = "identity", col = "white",  width = 1, size = 0.2) + 
  ggplot2::scale_x_discrete(expand = c(0, 0)) +
  ggplot2::coord_flip() +
  ggplot2::theme(
    aspect.ratio = NULL, 
    panel.grid = ggplot2::element_blank(), panel.spacing = grid::unit(1, "mm"), 
    strip.text = ggplot2::element_blank(),  strip.background = ggplot2::element_blank())
```

TODO: 计算丰度变化的显著性。

> Statistical significance of differences in the proportion of clusters between separate arrays and sequencing runs was performed using a Chi-square test. (Macosko, Evan Z., Anindita Basu, Rahul Satija, James Nemesh, Karthik Shekhar, Melissa Goldman, Itay Tirosh, et al. 2015. “Highly Parallel Genome-Wide Expression Profiling of Individual Cells Using Nanoliter Droplets.” Cell 161 (5): 1202–14. https://doi.org/10.1016/j.cell.2015.05.002.)

### 样本细胞数量

```{r}
# cell counts by sample
sample_cells_df <- reshape2::melt(table(sce$sample_id), varnames = "sample_id", value.name = "n_cells")
sample_cells_df$group_id <- sce$group_id[match(sample_cells_df$sample_id, sce$sample_id)]

p_sample_cells <- sample_cells_df %>%
  ggplot2::ggplot(ggplot2::aes(
    x = sample_id, y = n_cells, fill = group_id)) +
  ggplot2::scale_y_continuous("nb. of cells", limits = c(0, 7500), 
        breaks = seq(0, 7500, 2500), expand = c(0, 0)) +
  ggplot2::facet_wrap("group_id", ncol = 1, scales = "free_y") +
  ggplot2::geom_bar(stat = "identity", col = "white",  width = 1, size = 0.2) + 
  ggplot2::scale_x_discrete(expand = c(0, 0)) +
  ggplot2::coord_flip() +
  ggplot2::theme(aspect.ratio = NULL, 
    panel.grid = ggplot2::element_blank(), panel.spacing = grid::unit(1, "mm"), 
    strip.text = ggplot2::element_blank(),  strip.background = ggplot2::element_blank())
```

我们将两幅图合并起来：

```{r fig.height=5, fig.width=14}
p_cluster_percent + p_sample_cells
```


## 差异状态分析

### 实施 DS 分析

#### 将单细胞聚合成 pseudo-bulk 数据

差异状态分析有两类方法，其中之一是基于聚合数据的差异基因表达方法。

所以我们首先将单细胞数据聚合成 pseudo-bulk 数据：

```{r warning=FALSE}
pb_list <- list(
  "counts" = rhapsodykit::calculate_pseudo_bulk(sce, "counts"),
  "logcounts" = rhapsodykit::calculate_pseudo_bulk(sce, "logcounts"),
  "cpm" = rhapsodykit::calculate_pseudo_bulk(sce, "cpm")
  #"vstresiduals" = rhapsodykit::calculate_pseudo_bulk(sce, "vstresiduals")
)
```

变量 `pb` 实际上也是一个 `SingleCellExperiment` 对象，每一个 assay 都是一个 cluster 的 pseudo-bulk 数据。

我们需要通过 MDS plot 查看一下 pseudo-bulk 是否能够反应样本间的相似性：

```{r}
mds_plot_list <- lapply(pb_list, function(pb) {
  pb_mds <- muscat::pbMDS(pb)
  pb_mds +
    ggplot2::scale_shape_manual(values = c(15, 8, 10)) +
    ggplot2::theme(legend.position = "right", legend.box = "horizontal")
})
```

首先我们看看 `logcounts` 类型 pseudo-bulk 数据：

```{r}
mds_plot_list$logcounts
```

理论上，MDS 的第一个维度应该将 cluster 分开，第二个维度应该讲 group 分开。从结果上来看，MDS1 确实将 cluster 分开了；而 MDS2 也将 group 区分开，1DPI-MOCK 在 cluster 中总是靠下，1DPI-PNR2 靠中，1DPI-TR4 总是靠上。

然后是 `counts` 类型：

```{r}
mds_plot_list$counts
```

从 `counts` 类型数据的 MDS 图来看，我们可以很清晰的认识到 cluster 就是沿着 MDS1 被分开的。但是 group 在 MDS2 上的趋势不是很明显。

接着是 `cpm` 类型：

```{r}
mds_plot_list$cpm
```

我们可以发现 `cpm` 和 `counts` 类型数据的 MDS 图非常相似。因为本质上它们两者是一致的，并且都没有经过归一化，所以不适合用来画 MDS 图。

另外关于 CPM 的问题可以参见：https://github.com/HelenaLC/muscat/issues/66

#### 样品水平的分析: 基于聚合的方法

当我们组装好 pseudo-bulk 数据后，就可以开展基于聚合的差异状态分析了。基于聚合的差异状态方法依赖于 bulk RNA-Seq 领域已经常用的差异基表达分析方法，而这些方法对输入数据的数值类型是有要求的吗，比如：

-   limma-voom 和 edgeR 处理 pseudo-bulk counts；DESeq2 应该也是处理 pseudo-bulk counts
-   limma-trend 处理 library-size 归一化并且 log 转化后的 counts 平均值

各种差异状态分析方法依赖的数值类型可以参考 [HelenaLC/muscat-comparison](https://github.com/HelenaLC/muscat-comparison) 仓库库中 `scripts/meth_pars.R` 文件内容:

```{r eval=FALSE, include=FALSE}
pb <- dplyr::bind_rows(
    expand.grid(
        stringsAsFactors = FALSE,
        assay = "counts", fun = "sum", scale = FALSE, 
        method = c("edgeR", "limma-voom"),
        treat = c(FALSE, TRUE)
    ),
    expand.grid(
        stringsAsFactors = FALSE, scale = FALSE,
        assay = c("logcounts", "vstresiduals"),
        fun = "mean", method = "limma-trend"
    ),
    data.frame(
        stringsAsFactors = FALSE, scale = TRUE,
        assay = "cpm", fun = "sum", method = "edgeR",
        treat = c(FALSE, TRUE)
    )
)
```

可以使用 `muscat::pbDS` 函数完成任务，不过当要比较的 group 超过两个时，我们需要首先构建 design 矩阵以及 contrast 矩阵：

我们看看实验相关的信息，主要是 sample 属于哪个 group ：

```{r message=FALSE}
S4Vectors::metadata(sce)$experiment_info
```

在需要提供的数据中，design 矩阵起着指示器的作用，它用于表明样本属于哪个组。而 `model.matrix` 的统计学含义以及用法可以参考 [Expressing design formula in R](https://genomicsclass.github.io/book/pages/expressing_design_formula.html) 。contrast 矩阵用于表明我们想要比较哪两个组，以 `stim-ctrl` 字符串的形式指定，实验组在 `-` 前，对照组在后。我在 `rhapsodykit` 中提供了一个方便的帮助函数，自动构建 design 和 contrast 矩阵。

```{r}
# run DS analysis
ds_res <- list(
  edgeR = rhapsodykit::pseudobulk_diff_state(
    sce, pb_list$counts,
    method = "edgeR",
    contrasts = c(
      "X1DPI.PNR2-X1DPI.MOCK",
      "X1DPI.TR4-X1DPI.MOCK",
      "X1DPI.PNR2-X1DPI.TR4"
    )
  ),
  DESeq2 = rhapsodykit::pseudobulk_diff_state(
    sce, pb_list$counts,
    method = "DESeq2",
    contrasts = c(
      "X1DPI.PNR2-X1DPI.MOCK",
      "X1DPI.TR4-X1DPI.MOCK",
      "X1DPI.PNR2-X1DPI.TR4"
    )
  )
)

str(ds_res$edgeR$table, max.level = 1)
```

差异基因表达分析的结果储存在 `res_list` 列表中，而其成员则是 `contrast` 参数所指定的比较组合。每个比较组合又是一个列表，并且包含了针对每个 cluster 的差异表达分析结果。

```{r}
# access results table for 1st comparison
cluster1 <- ds_res$DESeq2$table[["X1DPI.PNR2-X1DPI.MOCK"]][[1]]
head(cluster1)
```

1DPI-PNR2 vs. 1DPI-MOCK 比较组合中 cluster 1 的差异基因表达结果如上所示。

#### 细胞水平的分析: 混合模型

如果我们不愿意基于聚合来展开差异状态分析，还可以基于细胞水平数据通过 Mixed Models 来完成差异状态分析。`muscat` 主要实现了三种方法：

1.  fitting linear mixed models (LMMs) on log-normalized data with observational weights;
2.  fitting LMMs on variance-stabilized data;
3.  fitting generalized linear mixed models (GLMMs) directly on counts.

```{r message=FALSE, eval=FALSE}
# 1st approach
mm_dream = muscat::mmDS(sce, n_threads = 2, method = "dream", n_cells = 10, n_samples = 2, min_count = 1, min_cells = 20)

# 2nd & 3rd approach
mm_vst = muscat::mmDS(sce, n_threads = 2, method = "vst", vst = "sctransform")
mm_nbinom = muscat::mmDS(sce, n_threads = 2, method = "nbinom")

str(mm_dream)
```

#### 寻找组间特异性标识基因

这里出现一个很有意义的问题：**如何找出 group 特异性的 DS 基因集**？

是否可以参考 Seurat 包鉴定 cluster 特异性 marker 的方法，将某个 group 与其余所有 group 一起比较。

阅读 `Seurat::FindAllMarkers` 源代码，找到鉴定 Marker 的方法。

> Seurat can help you find markers that define clusters via differential expression. By default, it identifies positive and negative markers of a single cluster (specified in `ident.1`), compared to all other cells.

也就是说，contrast 的一方是目标组，另一方是剩下所有样品。

```{r}
markers <- list(
  "PNR2"= rhapsodykit::find_group_marker_genes(sce, pb_list$counts, "X1DPI.PNR2" ,method = "DESeq2")
)

markers$PNR2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_summary()
```

### 处理结果

#### 结果的过滤与概览

我们要对差异状态分析的结果进行过滤，我们基于基因表达的变化幅度和显著性来过滤：

```{r}
# filter FDR < 5%, abs(logFC) > 1 & sort by adj. p-value
ds_res$edgeR %>%
  rhapsodykit::diff_state_significant(0.05, 1) %>%
  rhapsodykit::diff_state_summary()
```

然后是 DESeq2 的分析结果：

```{r}
ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant(0.05, 1) %>%
  rhapsodykit::diff_state_summary()
```


#### 计算表达频率

除了查看基因表达的变化幅度和显著性外，我们还可以看看基因表达的频率，即一个样本或组别中表达给定基因的细胞所占的比例。

```{r}
ds_res$edgeR %>%
  rhapsodykit::diff_state_significant(0.05, 1) %>%
  rhapsodykit::expr_freq_filter(sce) %>%
  rhapsodykit::diff_state_summary()
```

#### 格式化结果

当比较的组别数量非常多时，我们就需要将它们转化为一个方便查看或者操作的格式。其中 `res` 必须是 `muscat::pbDS` 或 `muscat::mmDS` 的计算结果。

```{r eval=FALSE}
# tidy format; attach pre-computed expression frequencies
muscat::resDS(sce, res, bind = "row", frq = frq)

# big-table (wide) format; attach CPMs
muscat::resDS(sce, res, bind = "col", cpm = TRUE)

# compute expression frequencies on the fly
muscat::resDS(sce, res, frq = TRUE)
```

### 对结果可视化

#### 可视化 DS 基因的数量

我们可以查看一下 edgeR 和 DESeq2 两种方法发现的差异基因数量：

```{r fig.height=7, fig.width=7}
patchwork::wrap_plots(
  ds_res$edgeR %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::genecount_diff_state() +
    ggplot2::ggtitle("edgeR"),
  ds_res$DESeq2 %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::genecount_diff_state() +
    ggplot2::ggtitle("DESeq2"),
  ncol = 1,
  guides = "collect"
)
```

总体来说，edgeR 与 DESeq2 发现的基因数量大体趋势是一致的，只不过两种方法计算出的 p_adj.loc 可能有所差别。从 TR4 与 PNR2 相对于 MOCK 的转录反应来看，小麦胚芽鞘似乎都不知道 *Fusarium. graminearum* 以及进入体内了。

我们首先画一下 `X1DPI.PNR2-X1DPI.MOCK` 火山图：

```{r}
df_to_plot <- ds_res$DESeq2 %>% rhapsodykit::diff_state_format()
dplyr::filter(df_to_plot, contrast == "X1DPI.PNR2-X1DPI.MOCK") %>%
  rhapsodykit::volcano_diff_state(title = "1DPI-PNR2 vs. 1DPI-MOCK")
```

然后看一下 `X1DPI.TR4-X1DPI.MOCK` 的火山图：

```{r}
dplyr::filter(df_to_plot, contrast == "X1DPI.TR4-X1DPI.MOCK") %>%
  rhapsodykit::volcano_diff_state(title = "X1DPI.TR4-X1DPI.MOCK")
```

最后比较一下 `X1DPI.PNR2-X1DPI.TR4`:

```{r}
dplyr::filter(df_to_plot, contrast == "X1DPI.PNR2-X1DPI.TR4") %>%
  rhapsodykit::volcano_diff_state(title = "X1DPI.PNR2-X1DPI.TR4")
```


#### 细胞亚群间差异状态的一致性

首先我们要准备具有丰富数据的 UpSetR 数据格式，参考 https://github.com/VCG/upset/wiki 页面来准备。

我们可以通过集合的可视化来看看细胞亚群之间的 DS 基因是否有交集：

```{r}
tbl_filtered <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  .$table %>% .[["X1DPI.PNR2-X1DPI.MOCK"]]

de_gs_by_k <- purrr::map(tbl_filtered, "gene")

ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.MOCK", 1:16, "gene") %>%
  rhapsodykit::from_list_to_upset() %>%
  rhapsodykit::upset_dataframe() %>%
  rhapsodykit::upset_plot()

ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", 1:16, "gene") %>%
  rhapsodykit::from_list_to_upset() %>%
  rhapsodykit::upset_dataframe() %>%
  rhapsodykit::upset_plot()

ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.TR4", 1:16, "gene") %>%
  rhapsodykit::from_list_to_upset() %>%
  rhapsodykit::upset_dataframe() %>%
  rhapsodykit::upset_plot()
```

TODO: 将上调和下调的基因分别显示出来。如何解决一个问题，某个基因在 cluster_1 中是上调，在 cluster_2 中是下调。 将上调基因与下调基因分成两个类别，分别计算出用于 UpSet Plot 的数据框。当某个基因在在两个集合中分别是上调基因和下调基因时，那么它在交集中就不会出现。

可以考虑将 up-regulated 和 down-regulated 分别生成两张可以直接画图的表格。然后将两张并合并在一起，标记一个 up 或者 down ，然后用 dogde 条形图绘制出来。

```{r}
plot_updown <- function(contrast) {
  up_list <- ds_res$DESeq2 %>%
    rhapsodykit::diff_state_filter(logFC > 0) %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull(contrast, 1:16, "gene")
  
  down_list <- ds_res$DESeq2 %>%
    rhapsodykit::diff_state_filter(logFC < 0) %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull(contrast, 1:16, "gene")
  
  rhapsodykit::upset_updown_regulated(up_list, down_list)
}

plot_updown("X1DPI.PNR2-X1DPI.MOCK") + ggplot2::ggtitle("1DPI PNR2 vs. MOCK")
plot_updown("X1DPI.TR4-X1DPI.MOCK") + ggplot2::ggtitle("1DPI TR4 vs. MOCK")
plot_updown("X1DPI.PNR2-X1DPI.TR4") + ggplot2::ggtitle("1DPI PNR2 vs. TR4")
```


Tips: 为什么 UpSetR 与 ggupset 画出来的数据不一致呢？当 `UpSetR::upset` 设置了 `nsets` 参数时，集合的交集计算只会在选定的集合之间进行。而 ggupset 默认显示所有集合，因此在默认参数状态下 UpSetR 与 ggupset 是有可能不一致的。

#### 样本间差异状态的一致性

```{r}
upset_contrasts <- function(input) {
  sets_list <- input$table %>%
    purrr::map(function(x) {
      purrr::map(x, "gene") %>%
        purrr::compact()
    })
  
  sets_metadata <- sets_list %>%
    purrr::imap(function(contrast, key) {
      cbind(
        sets = sprintf("%s [%s]", key, names(contrast)),
        contrast = key,
        cluster = names(contrast)
      )
    }) %>%
    do.call(rbind, .) %>%
    as.data.frame()

  sets_to_plot <- sets_list %>%
    unlist(recursive = FALSE)
  
  names(sets_to_plot) <- sets_metadata$sets

  sets_to_plot %>%
    rhapsodykit::from_list_to_upset() %>%
    UpSetR::upset(
      nsets = 6,
      cutoff = 5,
      text.scale = c(1, 1, 1, 1, 1, 0.75),
      set.metadata = list(
        data = sets_metadata,
        plots = list(
          list(
            type = "matrix_rows",
            column = "contrast",
            alpha = 0.4,
            colors = c(
              "X1DPI.PNR2-X1DPI.MOCK" = "green",
              "X1DPI.TR4-X1DPI.MOCK" = "navy",
              "X1DPI.PNR2-X1DPI.TR4" = "yellow"
            )
          )
        )
      ),
      # queries = list(
      #   list(
      #     query = UpSetR::intersects,
      #     params = list("X1DPI.PNR2-X1DPI.MOCK [1]", "X1DPI.TR4-X1DPI.MOCK [1]"),
      #     color = "orange",
      #     active = FALSE
      #   ),
      #   list(
      #     query = UpSetR::intersects,
      #     params = list("X1DPI.PNR2-X1DPI.MOCK [14]", "X1DPI.TR4-X1DPI.MOCK [14]"),
      #     color = "deepskyblue",
      #     active = FALSE
      #   )
      # )
    )
}

ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  upset_contrasts()
```

因为有不同的 contrast ，所以无法显示上调与下调的基因。

TODO: 针对某个 cluster ，绘制所有 contrast 的 UpSet 图。

#### 表达量在降维图上的投影

既然知道了差异基因，那么我们可以尝试将表达量投影到降维散点图中。

```{r}
# pull top-4 DS genes across all clusters
top4 <- dplyr::bind_rows(tbl_filtered) %>% 
  dplyr::top_n(4, dplyr::desc(p_adj.loc)) %>% 
  dplyr::pull("gene") %>%
  .[1:4]

# for ea. gene in 'top4', plot t-SNE colored by its expression 
ps <- lapply(top4, function(gene) {
  Seurat::DefaultAssay(obj) <- "RNA"
  Seurat::FeaturePlot(
      obj, gene,
      reduction = "tsne",
      pt.size = 0.05,
      label = FALSE) +
    ggplot2::ggtitle(gene) +
    ggplot2::theme_bw(8) +
    ggplot2::theme(legend.position = "none")
})

# arrange plots
cowplot::plot_grid(plotlist = ps, ncol = 2, align = "vh")
```

#### 细胞水平的可视化: 小提琴图

我们可以从细胞水平来看看这些 DS 基因的差异性分布：

```{r}
scater::plotExpression(sce[, sce$cluster_id == "Vascular Cells 4"],
  features = tbl_filtered$`Vascular Cells 4`$gene[seq_len(6)],
  x = "sample_id", colour_by = "group_id", ncol = 3) +
  ggplot2::guides(fill = ggplot2::guide_legend(override.aes = list(size = 5, alpha = 1))) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
```

用 `Seurat::VlnPlot` 画不出上面这个图。

#### 样本水平的可视化: Pseudobulk 热图

如果我们基于聚合来做 DS 分析，那么我们天然会想到画一个热图：

```{r}
pb_arr <- abind::abind(as.list(pb_list$logcounts@assays@data), along = 3)

genes <- dplyr::bind_rows(tbl_filtered) %>%
  dplyr::pull("gene")

# top-5 DS genes per cluster
rhapsodykit::heatmap_cross_sample(
  pb_arr, genes,
  clusters = c("Vascular Cells 4", "Vascular Cells 1"),
  type = "logcounts",
  show_row_names = FALSE)
```

待改进之处：

-   添加横坐标 group 注释
-   将横坐标以 group 分割

TODO: 参考 (Crowell et al. 2020) Fig. 4D 绘制一幅热图，寻找差异表达模组。

#### 差异基因的热图

利用 logFC 的表达情况来对基因集进行聚类，找出在表达模式上一致的模块。然后对这些模块再进行富集分析。

```{r eval=FALSE}
pbs <- pb_list$counts
ns <- length(levels(sce$sample_id))


# construct SCE containing logFCs for ea. cluster
ref <- pbs$group_id == "X1DPI.MOCK"
lfc <- lapply(
  SummarizedExperiment::assays(pbs),
  function(u) {
    y <- edgeR::DGEList(u)
    y <- edgeR::calcNormFactors(y)
    lcpm <- log1p(edgeR::cpm.DGEList(y))
    lfc <- lcpm - rowMeans(lcpm[, ref])
    SingleCellExperiment::SingleCellExperiment(
      lfc, colData = SingleCellExperiment::colData(pbs)
    )
  }
) %>% do.call(what = cbind)

lfc$cluster_id <- factor(
    rep(SummarizedExperiment::assayNames(pbs), each = ns), 
    levels = SummarizedExperiment::assayNames(pbs))

# consensus clustering of DS genes
ds_gs_by_k <- ds_res$edgeR %>%
  rhapsodykit::diff_state_significant() %>%
  .$table %>% .[["X1DPI.PNR2-X1DPI.MOCK"]] %>%
  purrr::map("gene")

ds_gs <- unique(unlist(ds_gs_by_k))
cc <- M3C::M3C(
  t(SummarizedExperiment::assay(lfc[ds_gs, ])),
  method = 2, 
  seed = NULL,
  removeplots = TRUE)
cc_ids <- cc$realdataresults[[3]]$assignments
cc_cols <- RColorBrewer::brewer.pal(length(unique(cc_ids)), "Set2")
names(cc_cols) <- unique(cc_ids)

# column & row annoations 
col_df <- data.frame(
    cluster_id = rep(SummarizedExperiment::assayNames(pbs), each = ns), 
    group_id = rep(pbs$group_id, length(SummarizedExperiment::assays(pbs))))
col_anno <- ComplexHeatmap::HeatmapAnnotation(
    df = col_df,
    show_annotation_name = FALSE,
    annotation_legend_param = list(
      title_gp = grid::gpar(fontsize = 8), 
      labels_gp = grid::gpar(fontsize = 6)
    )
)

row_anno <- ComplexHeatmap::rowAnnotation(
    show_annotation_name = FALSE,
    df = data.frame(consensus_id = cc_ids),
    col = list(consensus_id = cc_cols),
    simple_anno_size = grid::unit(2, "mm"),
    annotation_legend_param = list(
      title_gp = grid::gpar(fontsize = 8), 
      labels_gp = grid::gpar(fontsize = 6)
    )
)
# get axis limits by rounding limits of x to nearest n -------------------------
.get_brks <- function(x, n) {
    n <- 1 / n
    min <- floor(min(x) * n) / n
    max <- ceiling(max(x) * n) / n
    c(0, min, max)
}

.hm_lgd_aes <- list(
    title_gp = grid::gpar(fontsize = 8), 
    labels_gp = grid::gpar(fontsize = 6))

# cluster-wise logFC heatmap wrapper -------------------------------------------
.hm_cols <- c("navy", "cyan", "violet")

.plot_hm <- function(sce, col, brks, col_anno = NULL, row_anno = NULL, 
    row_split = NULL, row_nms = FALSE, col_title = NULL, ...)
    ComplexHeatmap::Heatmap(assay(sce), col, name = "logFC", 
        column_title = col_title, cluster_columns = FALSE, 
        show_row_names = row_nms, show_column_names = FALSE,
        show_row_dend = FALSE, show_column_dend = TRUE,
        row_split = row_split, column_split = sce$cluster_id,
        top_annotation = col_anno, left_annotation = row_anno, 
        heatmap_legend_param = c(.hm_lgd_aes, list(at = brks)),
        row_names_side = "left", ...)

qs <- quantile(SummarizedExperiment::assay(lfc[ds_gs, ]), c(0.01, 0.99))
brks <- .get_brks(qs, 0.5)
cols <- circlize::colorRamp2(brks, .hm_cols)
(hm <- .plot_hm(lfc[ds_gs, ], cols, brks, 
    col_anno, row_anno, cc_ids, row_title = NULL, 
    cluster_row_slices = FALSE, cluster_column_slices = FALSE, 
    use_raster = TRUE, raster_device = "CairoPNG"))
```

## 基因功能分析

### 基于 GO 注释的功能分析

首先我们要拿到小麦 GO 注释数据：

```{r}
# Get GO Data
# quote="" argument is neccessary for reading the complete table,
# because it disables quoting.
go_data <- read.table(
  "../../data/GOData.tsv", header = TRUE, sep = "\t", quote = "") %>%
  tibble::as_tibble()

go_data <- go_data %>%
  dplyr::filter(GO_ID != "")

go2gene <- go_data %>%
  dplyr::select(GO_ID, Gene_ID)
go2name <- go_data %>%
  dplyr::select(GO_ID, GO_Name)
```

#### 对差异状态基因做富集分析

要做富集分析我们首先要拿到一个基因列表。

```{r fig.height=7, fig.width=14}
p1 <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 1", "gene") %>%
  rhapsodykit::enrichment_analysis(go_data) %>%
  rhapsodykit::enrich_barplot(x = "Count", show_category = 20, title = "Vascular Cells 1 of 1DPI-TR4 vs. 1DPI-MOCK")

p2 <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.MOCK", "Vascular Cells 1", "gene") %>%
  rhapsodykit::enrichment_analysis(go_data) %>%
  rhapsodykit::enrich_barplot(x = "Count", show_category = 20, title = "Vascular Cells 1 of 1DPI-PNR2 vs. 1DPI-MOCK")

p3 <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant() %>%
  rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.TR4", "Unknown", "gene") %>%
  rhapsodykit::enrichment_analysis(go_data) %>%
  rhapsodykit::enrich_barplot(x = "Count", show_category = 20, title = "Unknown of 1DPI-PNR2 vs. 1DPI-TR4")

p1 + p2 + p3
```

现在我们可以从基因与 GO 的关系绘图：

```{r fig.height=8, fig.width=12}
sig_genes <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_significant()
genes <- sig_genes %>%
  rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 1", "gene")
fc <- sig_genes %>%
  rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 1", "logFC")
names(fc) <- genes

enr <- genes %>%
  clusterProfiler::enricher(TERM2GENE = go2gene, TERM2NAME = go2name)

rhapsodykit::enrich_cnetplot(enr, fold_change = fc, show_category = 20)
```

如果我们不将基因显示为 node ，而是将 GO 词条之间的链接定义为重叠基因的数量，也就是说 GO 词条之间重叠基因越多他们在图上的距离也就越近。这个功能叫做 Enrichment Map 。

```{r fig.height=7, fig.width=7}
enr %>%
  enrichplot::pairwise_termsim() %>%
  enrichplot::emapplot(cex_label_category = 0.6)
```


当要展示很多 GO 词条时，网络图就会变得非常复杂，我们可以试试 clusterProfiler 的 Heatmap-like functional classification 功能。不过这个热图似乎没有聚类，也就不是很方便人类阅读和理解了。TODO: 

```{r fig.height=7, fig.width=10}
enr %>%
  clusterProfiler::heatplot(foldChange = fc) +
  ggplot2::theme(axis.text.x = ggplot2::element_blank())
```

使用 UpSet 图似乎看起来更有意义。

```{r}
enr %>% enrichplot::upsetplot()
```

#### 对差异状态基因做 GSEA 分析

基于差异基因表达的富集分析可以找到差异较大的基因，但它发现不了那些虽然差异较小的，但在一组相关基因中以协调的方式得到证明的基因。因此 Gene Set Enrichment Analysis (GSEA) 直接关注这个问题。

GSEA 将一个基因集内各基因的统计数据聚合起来，因此有可能检测到一个预定义的基因集中所有基因以小而协调的方式变化的情况。因为许多相关的表型差异很可能是由一组基因中微小但一致的变化表现出来的。

基因是根据其表型进行排名的。给定一个预先的基因集 S (例如，共享相同 DO 类别的基因) ，GSEA 的目标是确定 S 的成员是随机分布在整个排序好的基因列表 (L)，还是主要存在于顶部或底部。.

For gene set enrichment analysis, we need a ranked list of genes. Suppose you are importing your own data from a csv file and the file contains two columns, one for gene ID (no duplicated allowed) and another one for fold change, you can prepare your own geneList via the following command:

```{r}
## 我们不需要依据 FDR 来筛选基因，只需要 logFC 来排序
gsea_df <- ds_res$DESeq2 %>%
  rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 1", c("gene", "logFC"))

## feature 1: numeric vector
geneList <- gsea_df[,2]

## feature 2: named vector
names(geneList) <- as.character(gsea_df[,1])

## feature 3: decreasing order
geneList <- sort(geneList, decreasing = TRUE)

```

问题是从哪里去找通路数据库呢？似乎 [Plant Reactome](https://plantreactome.gramene.org/) 很不错的样子。

似乎可以用 `clusterProfiler::GSEA()` 函数：

```{r}
gsea <- clusterProfiler::GSEA(geneList, TERM2GENE = go2gene, TERM2NAME = go2name)

rhapsodykit::enrich_cnetplot(gsea, fold_change = geneList, show_category = 20)
```

```{r fig.height=7, fig.width=7}
gsea %>%
  enrichplot::pairwise_termsim() %>%
  enrichplot::emapplot(cex_label_category = 0.6)
```

```{r fig.height=7, fig.width=10}
gsea %>%
  enrichplot::upsetplot()
```


```{r fig.height=7, fig.width=14}
gsea %>%
  enrichplot::ridgeplot()
```

```{r}
gsea %>%
  enrichplot::gseaplot(geneSetID = 3, title = gsea$Description[3])
```

```{r fig.height=7, fig.width=14}
gsea %>%
  enrichplot::gseaplot2(geneSetID = 1:5)
```

```{r}
gsea %>%
  enrichplot::gsearank(geneSetID = 3, title = gsea$Description[3])
```

#### 差异状态基因的生物主题比较

我们可以试试 clusterProfiler 生物主题比较功能：

```{r fig.height=14, fig.width=8}
compare_list <- list(
  "VCs_1.1DPI.TR4.MOCK" = ds_res$DESeq2 %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 1", "gene"),
  "VCs_1.1DPI.PNR2.MOCK" = ds_res$DESeq2 %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.MOCK", "Vascular Cells 1", "gene"),
  "VCs_4.1DPI.TR4.MOCK" = ds_res$DESeq2 %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull("X1DPI.TR4-X1DPI.MOCK", "Vascular Cells 4", "gene"),
  "VCs_4.1DPI.PNR2.MOCK" = ds_res$DESeq2 %>%
    rhapsodykit::diff_state_significant() %>%
    rhapsodykit::diff_state_pull("X1DPI.PNR2-X1DPI.MOCK", "Vascular Cells 4", "gene")
)

comp_enr <- clusterProfiler::compareCluster(compare_list, fun = "enricher", TERM2GENE = go2gene, TERM2NAME = go2name)

enrichplot::dotplot(comp_enr, showCategory = 20, by = "count") +
  #ggplot2::scale_y_discrete(expand = ggplot2::expansion(c(0, 0), c(1, 1))) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))
```

TODO: 将 dotplot 按照 cluster 来 facet 化，然后 x 轴显示 contrast 就好了。
TODO: 将 enrichplot::dotplot 与 ggupset 结合到一起，看看能否提供更方便快捷的理解方式。

参考资料：

* [Biological theme comparison](http://yulab-smu.top/clusterProfiler-book/chapter11.html)
* [biological-theme-comparison](https://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html#biological-theme-comparison) 
* Yu, G., Wang, L.-G., Han, Y., & He, Q.-Y. (2012). clusterProfiler: An R Package for Comparing Biological Themes Among Gene Clusters. OMICS: A Journal of Integrative Biology, 16(5), 284–287. https://doi.org/10.1089/omi.2011.0118

然后看看 GO 词条之间的关联：

```{r fig.height=7, fig.width=10}
comp_enr %>%
  enrichplot::pairwise_termsim() %>%
  enrichplot::emapplot(legend_n = 2)
```

### 其他注释的功能分析

比如 KEGG 或 [Plant Reactome](https://plantreactome.gramene.org/)