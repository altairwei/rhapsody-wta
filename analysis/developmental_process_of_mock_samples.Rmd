---
title: "Developmental Process of MOCK Samples"
author: "Altair Wei"
date: '2022-10-05'
output: html_document
---

```{r setup, include=FALSE}
library(SingleCellExperiment)
knitr::opts_chunk$set(echo = TRUE)
source("../scripts/TrajectoryUtilities.R")
plt <- reticulate::import("matplotlib.pyplot")
scv <- reticulate::import("scvelo")
```

```{python}
import scvelo as scv
import matplotlib.pyplot as plt
import scanpy as sc
```

```{r message=FALSE, warning=FALSE, results="hide"}
library(org.Taestivum.iwgsc.db)
orgdb <- org.Taestivum.iwgsc.db
```

## 1 准备数据集

```{r}
samples <- c(
  "0DPI-MOCK-1",
  "0DPI-MOCK-2",
  "1DPI-MOCK-1",
  "1DPI-MOCK-2",
  "2DPI-MOCK-1",
  "2DPI-MOCK-2",
  "3DPI-MOCK-1",
  "3DPI-MOCK-2"
)

data_folders <- structure(
  paste0("../results/RawOutput/", samples), names = samples)

data_list <- xfun::cache_rds(
  file = "velocity_mock_data_list.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = lapply(data_folders, function(base_dir) {
    loom_file = paste0(base_dir, "/Velocyto/", basename(base_dir), ".loom")
    SeuratWrappers::ReadVelocity(loom_file)
   })
)
```

```{r}
fixCellNames <- function(mtx_list) {
  lapply(mtx_list, function(mtx) {
    colnames(mtx) <- colnames(mtx) |>
      stringr::str_sub(end = -2L) |>
      stringr::str_replace(stringr::fixed(":"), "_")
    mtx
  })
}

spliced <- xfun::cache_rds(
  file = "velocity_mock_mtx_spliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "spliced")))
)

unspliced <- xfun::cache_rds(
  file = "velocity_mock_mtx_unspliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "unspliced")))
)

ambiguous <- xfun::cache_rds(
  file = "velocity_mock_mtx_ambiguous.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "ambiguous")))
)
```

```{r}
obj_mock <- readRDS(Sys.glob(
  "../results/ObjectCache/IntegrationAndAnnotation/obj_mock_annotated_*.rds"))
```

```{r}
sce_mock <- xfun::cache_rds(
  file = "sce_mock_spliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = local({
    obj_mock$cellType <- Seurat::Idents(obj_mock)
    sce <- Seurat::as.SingleCellExperiment(obj_mock, assay = "RNA")
    sce <- muscat::prepSCE(sce,
      kid = "ident", # subpopulation assignments
      gid = "group", # group IDs (ctrl/stim)
      sid = "sample", # sample IDs (ctrl/stim.1234)
      drop = FALSE
    )

    cell_names <- colnames(sce)
    gene_names <- rownames(sce)
    assay(sce, "spliced") <- spliced[gene_names, cell_names]
    assay(sce, "unspliced") <- unspliced[gene_names, cell_names]

    sce
  })
)
```

## 2 降维分析 {.tabset}

```{r}
sce_mock <- runDiffusionMap(sce_mock, dimred = "HARMONY")
sce_mock <- runPHATE(sce_mock, dimred = "HARMONY")
```

### UMAP

```{r}
scater::plotUMAP(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### t-SNE

```{r}
scater::plotTSNE(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### DiffusionMap

```{r}
scater::plotDiffusionMap(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### PHATE

```{r}
scater::plotReducedDim(sce_mock, dimred = "PHATE", colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

## 3 共变邻域分析

```{r}
obj_mock$time_val <- as.numeric(factor(
  obj_mock$time, levels = c("0DPI", "1DPI", "2DPI", "3DPI")))

obj_mock <- rcna::association.Seurat(
  seurat_object = obj_mock,
  test_var = "time_val",
  samplem_key = "sample",
  graph_use = "RNA_nn",
  batches = NULL,
  covs = NULL
)
```

### 时间系列

```{r fig.height=3, fig.width=11}
Seurat::DimPlot(obj_mock, reduction = "umap", split.by = "time") &
  ggplot2::coord_fixed()
```

### 表型关联结果 {.tabset}

```{r}
blue_to_orange <- rev(ggthemes::ggthemes_data[[
  c("tableau", "color-palettes", "ordered-diverging", "Orange-Blue Diverging")]][["value"]])
```

在下面的图中，每个单元格根据其邻域系数着色，即颜色对应于每个细胞相应邻域的丰度与样本属性的相关性。由于我们将时间编码成了数字，因此从蓝色到橙红色代表了 0DPI ~ 3DPI 的邻域系数。

#### UMAP

```{r fig.height=8, fig.width=16}
p1 <- Seurat::FeaturePlot(obj_mock, reduction = "umap", features = c("cna_ncorrs")) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p2 <- Seurat::DimPlot(obj_mock, reduction = "umap", group = "group") &
  ggplot2::coord_fixed()

p1[[1]] + p2 + patchwork::plot_layout(nrow = 1)
```

#### t-SNE

```{r fig.height=8, fig.width=16}
p1 <- Seurat::FeaturePlot(obj_mock, reduction = "tsne", features = c("cna_ncorrs")) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p2 <- Seurat::DimPlot(obj_mock, reduction = "tsne", group = "group") &
  ggplot2::coord_fixed()

p1[[1]] + p2 + patchwork::plot_layout(nrow = 1)
```

### Neighborhood loadings of NAM PCs

查看源代码可知，`NAM_nbhdXpc` 等于 `NAM_embeddings`，而 `NAM_sampleXpc` 等于 `NAM_loadings` 。

```{r fig.height=8, fig.width=14}
p <- Seurat::FeaturePlot(
    obj_mock, reduction = "umap",
    features = paste0("NAMPC_", 1:6),
    ncol = 3, order = TRUE) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p
```

### Variance explained by NAM PCs

```{r}
data.frame(
  sig2 = obj_mock@reductions$cna@misc$NAM_svs
          / sum(obj_mock@reductions$cna@misc$NAM_svs)) |>
    tibble::rowid_to_column('PC') |>
    ggplot2::ggplot(ggplot2::aes(PC, sig2)) + 
        ggplot2::geom_point() + 
        ggplot2::geom_line() + 
        ggplot2::theme_classic(base_size = 14) + 
        ggplot2::labs(y = 'Fraction of variance explained', x = 'NAM PC') + 
        ggplot2::scale_x_continuous(breaks = 1:20)
```

### Per-gene correlations to neighborhood coefficient

```{r}
ncorrs <- as(matrix(obj_mock$cna_ncorrs, ncol = 1), "dgCMatrix")
genes <- qlcMatrix::corSparse(ncorrs, t(obj_mock@assays$RNA@counts))
genes <- structure(as.numeric(genes), names = rownames(obj_mock@assays$RNA@counts))
genes <- sort(genes, decreasing = TRUE)
```

```{r}
gsea <- clusterProfiler::gseGO(
  genes,
  ont = "BP",
  OrgDb = org.Taestivum.iwgsc.db,
  keyType = "GID"
)

gsea <- clusterProfiler::simplify(gsea)
```

```{r fig.height=10, fig.width=10}
p <- gsea |>
  enrichplot::pairwise_termsim() |>
  enrichplot::treeplot(
    showCategory = 40, nCluster = 12,
    offset = 20, offset_tiplab = 1,
    label_format_cladelab = 5, color = "NES",
    geneClusterPanel = "dotplot", nWords = 0) +
  ggplot2::scale_y_continuous(expand = ggplot2::expansion(mult = c(0, 0), add = c(6, 0))) +
  ggplot2::scale_color_gradient2(low = "blue", mid = "white", high = "red", name = "NES") +
  ggplot2::coord_cartesian()
p
```

从上面的 GO 词条来看，这确实像是发育程序。

### Sample loadings of NAM PCs

```{r}
sample_df <- as.data.frame(obj_mock@reductions$cna@feature.loadings[, 1:2])
sample_df$sample <- stringr::str_extract(rownames(sample_df), "\\dDPI-MOCK")

ggplot2::ggplot(sample_df, ggplot2::aes(NAMPC_1, NAMPC_2, color = sample)) +
  ggplot2::geom_point()
```

## 4 RNA 速率

```{r}
adata <- runScVelo(
  sce_mock,
  mode = "dynamical",
  use.dimred = "HARMONY",
  assay.X = "logcounts",
  scvelo.params = list(
    filter_and_normalize = list(
      min_shared_counts = 20L, n_top_genes = 2000L),
    moments = list(n_pcs = 30L, n_neighbors = 30L)
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata$obsm$update(list(
  X_tsne = reducedDim(sce_mock, "TSNE"),
  X_umap = reducedDim(sce_mock, "UMAP")
))

adata$obs$cellType <- sce_mock$cluster_id
```

### 速率流线 {.tabset}

#### UMAP

```{python plot-stream-umap, fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata, basis="umap", color="cellType", figsize = (7, 7))
```

#### t-SNE

```{python plot-stream-tsne, fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata, basis="tsne", color="cellType", figsize= (7, 7))
```

### 速率细胞 {.tabset}

#### UMAP

```{python plot-velo-umap, fig.height=12, fig.width=12}
scv.pl.velocity_embedding(
  r.adata, basis="umap", color="cellType", figsize=(12, 12),
  arrow_length=6, arrow_size=3, scale=2, dpi=300)
```

#### t-SNE

```{python plot-velo-tsne, fig.height=12, fig.width=12}
scv.pl.velocity_embedding(
  r.adata, basis="tsne", color="cellType", figsize=(12, 12),
  arrow_length=6, arrow_size=3, scale=2, dpi=300)
```

### 速度 {.tabset}

> The speed or rate of differentiation is given by the length of the velocity vector.

```{python}
kwargs=dict(cmap='coolwarm', size=10, perc=[5, 95], figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_length', basis="umap", **kwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_length', basis="tsne", **kwargs)
```

### 连贯性 {.tabset}

> The coherence of the vector field (i.e., how a velocity vector correlates with its neighboring velocities) provides a measure of confidence.

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_confidence', basis="umap", **kwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_confidence', basis="tsne", **kwargs)
```

### 速率图 {.tabset}

> We can visualize the velocity graph to portray all velocity-inferred cell-to-cell connections/transitions. It can be confined to high-probability transitions by setting a `threshold`.

```{python}
vgkwargs=dict(threshold=5, size=10, alpha=.2, color="cellType", figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.velocity_graph(r.adata, basis="umap", **vgkwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.velocity_graph(r.adata, basis="tsne", **vgkwargs)
```

### 速率拟时序 {.tabset}

> Finally, based on the velocity graph, a velocity pseudotime can be computed. After inferring a distribution over root cells from the graph, it measures the average number of steps it takes to reach a cell after walking along the graph starting from the root cells.
>
> Contrarily to diffusion pseudotime, it implicitly infers the root cells and is based on the directed velocity graph instead of the similarity-based diffusion kernel.

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(
  r.adata, color='velocity_pseudotime', cmap='gnuplot',
  basis='umap', figsize=(7, 7))
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(
  r.adata, color='velocity_pseudotime', cmap='gnuplot',
  basis='tsne', figsize=(7, 7))
```

### 隐时间 {.tabset}

> The dynamical model recovers the latent time of the underlying cellular processes. This latent time represents the cell’s internal clock and approximates the real time experienced by cells as they differentiate, based only on its transcriptional dynamics.
>
> scVelo’s latent time is based only on its transcriptional dynamics and represents
the cell’s internal clock. It captures aspects of the actual time better than similarity-based diffusion pseudo-time.

```{python}
ltkwargs=dict(color='latent_time', color_map='gnuplot', size=20, figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, basis="umap", **ltkwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, basis="tsne", **ltkwargs)
```

### PAGA 图 {.tabset}

> PAGA graph abstraction has benchmarked as top-performing method for trajectory inference. It provides a graph-like map of the data topology with weighted edges corresponding to the connectivity between two clusters. Here, PAGA is extended by velocity-inferred directionality.

```{python}
r.adata.uns['neighbors']['distances'] = r.adata.obsp['distances']
r.adata.uns['neighbors']['connectivities'] = r.adata.obsp['connectivities']

scv.tl.paga(r.adata, groups='cellType')
```

#### UMAP

```{python fig.width=7, fig.height=7}
scv.pl.paga(r.adata, basis='umap', size=50, alpha=.1,
            min_edge_width=2, node_size_scale=1.5, figsize=(7, 7))
```

#### t-SNE

```{python fig.width=7, fig.height=7}
scv.pl.paga(r.adata, basis='tsne', size=50, alpha=.1,
            min_edge_width=2, node_size_scale=1.5, figsize=(7, 7))
```

## 5 轨迹推断

### 叶肉细胞

```{r}
sce_me <- sce_mock[, sce_me$cluster_id %in% paste0("Me_", 1:5)]
```

```{r}
adata <- runScVelo(
  sce_me,
  mode = "dynamical",
  use.dimred = "HARMONY",
  assay.X = "logcounts",
  scvelo.params = list(
    filter_and_normalize = list(
      min_shared_counts = 20L, n_top_genes = 2000L),
    moments = list(n_pcs = 30L, n_neighbors = 30L)
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata$obsm$update(list(
  X_tsne = reducedDim(sce_me, "TSNE"),
  X_umap = reducedDim(sce_me, "UMAP")
))

adata$obs$cellType <- sce_me$cluster_id
```

```{python plot-stream-umap, fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata, basis="umap", color="cellType", figsize = (7, 7))
```

解决 slingshot pseudotime 分布不均匀的问题：

1. 使用 DPT 计算 pseudotime：{destiny} 可以计算 DPT。如果使用 DPT 的话，DiffusionMap 要当成概括化方法来用，而不仅仅是可视化方法，但参考教程中是基于 PCA 来计算 DiffusionMap 然后再计算 DPT 的。参考 https://broadinstitute.github.io/2020_scWorkshop/trajectory-analysis.html 但如果这样的化，harmony 该应用在什么地方？cluster 也得发生变化？

2. Slingshot 计算 pseudotime 的方式：pseudotime values are obtained by orthogonal projection onto curves，所以我们需要看看 HARMONY 空间的细胞与曲线的相对位置。

3. 对 harmony 取子集，然后用 diffusion map 简约掉多余的轴？再将结果喂给 slingshot 。

#### Slingshot

```{r}
sce_me <- runDiffusionMap(sce_me, dimred = "HARMONY", ncomponents = 10, n_eigs = 10)
```

##### 基于 HARMONY

```{r}
sce_me <- slingshot::slingshot(sce_me,
  clusterLabels = sce_me$cluster_id,
  reducedDim = "HARMONY", start.clus = "Me_1",
  approx_points = FALSE)
```

```{r fig.height=7, fig.width=14}
p1 <- plotSlingshotCurveOnReduc(sce_me, reduction = "HARMONY")
p2 <- plotSlingshotCurveOnReduc(sce_me, reduction = "UMAP")
p3 <- plotSlingshotCurveOnReduc(sce_me, reduction = "DiffusionMap")
p1 + p2 + p3
```

```{r}
psts <- slingshot::slingPseudotime(sce_me) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  #ggplot2::facet_wrap(~lineages) +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

测序深度对 pseudotime 计算有影响吗？

```{r}
p1 <- scater::plotColData(sce_me, "nCount_RNA", "cluster_id",
                          colour_by = "slingPseudotime_1", point_size = .1) +
  ggplot2::scale_y_log10()
p2 <- scater::plotColData(sce_me, "nCount_RNA", "cluster_id",
                          colour_by = "slingPseudotime_2", point_size = .1) +
  ggplot2::scale_y_log10()

p1/p2
```

##### 基于 DC

```{r}
sce_me <- slingshot::slingshot(sce_me,
  clusterLabels = sce_me$cluster_id,
  reducedDim = "DiffusionMap", start.clus = "Me_2",
  approx_points = FALSE)
```

```{r fig.height=7, fig.width=14}
p1 <- plotSlingshotCurveOnReduc(sce_me, reduction = "HARMONY")
p2 <- plotSlingshotCurveOnReduc(sce_me, reduction = "UMAP")
p3 <- plotSlingshotCurveOnReduc(sce_me, reduction = "DiffusionMap")
p1 + p2 + p3
```

```{r}
psts <- slingshot::slingPseudotime(sce_me) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  #ggplot2::facet_wrap(~lineages) +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

#### Diffusion Pseudotime

```{r}
harmony <- reducedDim(sce_me, "HARMONY")
dm <- destiny::DiffusionMap(harmony)

#dpt <- destiny::DPT(dm, tips = which(colnames(sce_me) == "1DPI-MOCK-1_184678"))
dpt <- destiny::DPT(dm, tips = sample(which(sce_me$cluster_id == "Me_2"), size = 1))
```

```{r}
df <- data.frame(DC1 = destiny::eigenvectors(dm)[, 1],
                 DC2 = destiny::eigenvectors(dm)[, 2], 
                 dptval = dpt$dpt, cell_type = sce_me$cluster_id)
p1 <- ggplot2::ggplot(df) + ggplot2::geom_point(ggplot2::aes(x = DC1, y = DC2, color = dptval))
p2 <- ggplot2::ggplot(df) + ggplot2::geom_point(ggplot2::aes(x = DC1, y = DC2, color = cell_type))
p <- cowplot::plot_grid(p1, p2)
p
```

```{r}
ggplot2::ggplot(data.frame(pseudotime = dpt$dpt), ggplot2::aes(x = pseudotime)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  cowplot::theme_cowplot()
```

#### scVelo

```{r}
adata$obsm$update(list(
  X_dc = reducedDim(sce_me, "DiffusionMap")
))
```

```{python plot-velo-umap, fig.height=12, fig.width=12}
scv.pl.velocity_embedding(
  r.adata, basis="dc", color="cellType", figsize=(12, 12),
  arrow_length=6, arrow_size=2, scale=2, dpi=300)
```
```{python fig.height=7, fig.width=7}
scv.pl.scatter(
  r.adata, color='velocity_pseudotime', cmap='gnuplot',
  basis='dc', size=20, figsize=(7, 7))
```
```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, basis="dc", color='latent_time', color_map='gnuplot', size=20, figsize=(7, 7))
```
```{r}
ggplot2::ggplot(data.frame(pseudotime = adata$obs$latent_time), ggplot2::aes(x = pseudotime)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  cowplot::theme_cowplot()
```

#### PAGA

```{r}
sc <- reticulate::import("scanpy")
```

```{r}
sc$tl$paga(adata, groups='cellType')
```

```{python fig.width=7, fig.height=7}
sc.pl.paga(r.adata, threshold=0.4, show=True)
```

```{python fig.width=7, fig.height=7}
sc.pl.umap(r.adata, color='cellType', legend_loc='on data', size=20)
```

```{python}
sc.pl.paga_compare(
    r.adata, basis='umap', threshold=0.5, title='', right_margin=0.2, size=10, edge_width_scale=0.5,
    legend_fontsize=12, fontsize=12, frameon=False, edges=True, save=False)
```

```{python}
import numpy as np
r.adata.uns['iroot'] = np.flatnonzero(r.adata.obs['cellType']  == 'Me_2')[0]
sc.tl.dpt(r.adata)
```

```{python fig.width=7, fig.height=7}
sc.pl.umap(r.adata, color='dpt_pseudotime', legend_loc='on data', size=20)
```
