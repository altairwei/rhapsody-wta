---
title: "Sources of Stress State Subpopulations"
author: "Altair Wei"
date: "2022/3/4"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(Matrix)
library(patchwork)
library(SingleCellExperiment)
library(TrajectoryUtils)
source("../scripts/TrajectoryUtilities.R")
sc <- reticulate::import("scanpy")
scv <- reticulate::import("scvelo")
```

```{python}
import scvelo as scv
import matplotlib.pyplot as plt
import scanpy as sc
```

```{r message=FALSE, warning=FALSE, results="hide"}
library(org.Taestivum.iwgsc.db)
orgdb <- org.Taestivum.iwgsc.db
```

```{r}
sce <- readRDS(Sys.glob("../results/ObjectCache/TrajectoryInference/sce_spliced_*.rds"))
```

## 1 差异轨迹分析 1DPI 样本

```{r}
sce_1dpi <- sce[, sce$time == "1DPI"]
```

### 1.1 整体分析

#### 降维可视化 {.tabset}

```{r}
sce_1dpi <- runDiffusionMap(sce_1dpi, dimred = "HARMONY")
sce_1dpi <- runPHATE(sce_1dpi, dimred = "HARMONY")
```

##### t-SNE

```{r}
scater::plotReducedDim(sce_1dpi, dimred = "TSNE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### UMAP

```{r}
scater::plotReducedDim(sce_1dpi, dimred = "UMAP",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PHATE

```{r}
scater::plotReducedDim(sce_1dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### 细胞种群连接性

```{r}
adata_1dpi <- readPickle(Sys.glob(
  "../results/ObjectCache/TrajectoryInference/scvelo_adata_1dpi_*.pickle"))
```

```{r}
adata_1dpi$obsm$update(list(
  X_tsne = reducedDim(sce_1dpi, "TSNE"),
  X_umap = reducedDim(sce_1dpi, "UMAP"),
  X_phate = reducedDim(sce_1dpi, "PHATE")
))

adata_1dpi$obs$cellType <- sce_1dpi$cluster_id
```

```{r}
sc$tl$paga(adata_1dpi, groups='cellType')
scv$tl$paga(adata_1dpi, groups='cellType')
```

```{r fig.height=7, fig.width=14}
p1 <- plotPagaGraph(adata_1dpi, basis="tsne", threshold = 0.25) +
  ggplot2::coord_fixed()
p2 <- plotPagaGraph(adata_1dpi, basis="umap", threshold = 0.25) +
  ggplot2::coord_fixed()

p1 + p2
```

PAGA 连接性的含义：

> For simple, coarse-grained visualization, compute the PAGA graph, a coarse-grained and simplified (abstracted) graph. Non-significant edges in the coarse- grained graph are thresholded away.
>
> A PAGA graph is obtained by associating a node with each partition and connecting each node by weighted edges that represent a statistical measure of connectivity between partitions.

### 1.2 叶肉细胞世系

Me_5 和 Me_6 似乎会干扰轨迹的推断，并且细胞身份都与 Me_γ 有关，所以没必要加进去。Va_1 要不要加入还需要考虑，因为他大部分来自 Va_α，小部分来自 Me_α 和 Me_β 。

```{r}
cells_chosen <- sce_1dpi$cluster_id %in% c(
  "Me_1", "Me_2", "Me_4", "Me_3", "Va_1")
sce_me_da_1dpi <- sce_1dpi[, cells_chosen]
sce_me_da_1dpi <- sce_me_da_1dpi[
  Matrix::rowSums(counts(sce_me_da_1dpi) > 0) > 10, ]
```

#### 降维可视化 {.tabset}

```{r}
sce_me_da_1dpi <- scater::runUMAP(sce_me_da_1dpi, dimred = "HARMONY", ncomponents = 30L)
sce_me_da_1dpi <- runDiffusionMap(sce_me_da_1dpi, dimred = "HARMONY")
sce_me_da_1dpi <- runPHATE(sce_me_da_1dpi, dimred = "HARMONY")
```

##### HARMONY

```{r}
scater::plotReducedDim(sce_me_da_1dpi,
    dimred = "HARMONY",
    ncomponents = c(7, 17),
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PAHTE

```{r}
scater::plotReducedDim(sce_me_da_1dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### DiffusionMap

```{r}
scater::plotReducedDim(sce_me_da_1dpi, dimred = "DiffusionMap",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_1dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### RNA 速率

```{r}
adata_me_da_1dpi <- cache_pickle(
  file = "scvelo_me_da_1dpi.pickle",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = runScVelo(
    sce_me_da_1dpi,
    mode = "dynamical",
    use.dimred = "HARMONY",
    assay.X = "logcounts",
    scvelo.params = list(
      filter_and_normalize = list(
        min_shared_counts = 20L, n_top_genes = 2000L),
      moments = list(n_pcs = 30L, n_neighbors = 30L)
    )
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata_me_da_1dpi$obsm$update(list(
  X_tsne = reducedDim(sce_me_da_1dpi, "TSNE"),
  X_umap = reducedDim(sce_me_da_1dpi, "UMAP")
))

adata_me_da_1dpi$obs$cellType <- as.character(sce_me_da_1dpi$cluster_id)
```

```{python fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata_me_da_1dpi, basis="umap", color="cellType", figsize = (7, 7))
```

#### 轨迹推断

```{r}
sce_me_da_1dpi <- xfun::cache_rds(
  file = "slingshot_me_da_1dpi.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = slingshot::slingshot(sce_me_da_1dpi,
    clusterLabels = sce_me_da_1dpi$cluster_id,
    reducedDim = "UMAP", approx_points = 500,
    start.clus = "Me_4", end.clus = c("Me_1", "Me_2"))
)
```

##### 细胞世系 {.tabset}

###### HARMONY

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_1dpi, dimred = "HARMONY", ncomponents = c(7, 17))
```

###### DiffusionMap

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_1dpi, dimred = "DiffusionMap")
```

###### PHATE

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_1dpi, dimred = "PHATE")
```

##### 拟时间分布

```{r fig.height=3, fig.width=7}
psts <- slingshot::slingPseudotime(sce_me_da_1dpi) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages, scales = "free_x") +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```


#### 差异进程分析

```{r}
psts <- slingshot::slingPseudotime(sce_me_da_1dpi$slingshot) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_1dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "pseudotime", names_to = "lineages")
```

```{r fig.height=3, fig.width=7}
ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = conditions)) +
    ggplot2::geom_density(alpha = .5) +
    #ggridges::geom_density_ridges(ggplot2::aes(y = conditions), scale = 4) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_wrap(~lineages, scales = "free_x") +
    cowplot::theme_cowplot() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white")
    )
```

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_1dpi, dimred = "PHATE")
```

```{r fig.height=4, fig.width=13}
p1 <- scater::plotReducedDim(
    sce_me_da_1dpi, dimred = "PHATE", colour_by = "cellType") +
  ggplot2::coord_fixed()

p2 <- scater::plotReducedDim(
    sce_me_da_1dpi, dimred = "PHATE", colour_by = "treatment") +
  ggplot2::coord_fixed()

p1 + p2
```


##### 差异拓扑

> Test whether or not slingshot should be fitted independently for different conditions or not. The null hypothesis that a common trajectory should be fitted.

```{r}
top_res <- condiments::topologyTest(
  sds = sce_me_da_1dpi$slingshot,
  conditions = sce_me_da_1dpi$treatment,
  methods = "Classifier",
  threshs = 0.05)
```

```{r}
top_res
```

虽然拒绝了零假设，但为了方便起见我们就不单独拟合轨迹了。

##### 差异进程

```{r}
prog_res  <- condiments::progressionTest(
  pseudotime = sce_me_da_1dpi,
  conditions = sce_me_da_1dpi$treatment,
  lineages = TRUE, method = "KS")
```

```{r}
prog_res
```

上面这个用的是 Classifier ，但我们想要是 condition 之间的两两比较。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_1dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_1dpi)
mock_cells <- sce_me_da_1dpi$treatment == "MOCK"
pnr2_cells <- sce_me_da_1dpi$treatment == "PNR2"
tr4_cells <- sce_me_da_1dpi$treatment == "TR4"
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[pnr2_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[pnr2_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[pnr2_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[pnr2_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[pnr2_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[pnr2_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
```

可以看出与 Lineage1 相比，Lineage2 的 MOCK 与 PNR2/TR4 的分布差异是显著的 (p-value < 0.05)。

##### 差异命运选择

> The distribution has tri modes, which is very often the case for two lineages.
> - Weight around 0 represent a cell that is mostly assigned to the other lineage.
> - Weight around .5 represent a cell that is equally assigned to both lineages.
> - Weight around 1 represent a cell that is mostly assigned to this lineage.
> However, it is important to note that the sum of all lineage weights should sum to 1. As such, we can only plot the weights for the first lineage.

```{r fig.height=3, fig.width=7}
ws <- slingshot::slingCurveWeights(sce_me_da_1dpi$slingshot, as.probs = TRUE) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_1dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "weight", names_to = "lineages")

ggplot2::ggplot(ws, ggplot2::aes(x = weight, fill = conditions)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages) +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

TR4 倾向于沿着 Lineage1 转变，因为它在 Lineage1 具有更多的 0.5 和更少的 0 权重细胞。反之，PNR2 倾向于 Lineage2 。另一个值得注意的是，Lineage2 的总细胞数明显少于 Lineage1 ，所以前者权重为 0 的数量多于权重为 1 的数量。

> Test whether or not the cell repartition between lineages is independent of the conditions

因为我们这里只有两个世系，所有 `pairwise=TRUE` 没啥意义。

```{r}
dif_res <- condiments::fateSelectionTest(
  cellWeights = sce_me_da_1dpi$slingshot,
  conditions = sce_me_da_1dpi$treatment,
  global = FALSE, pairwise = FALSE)
```

```{r}
dif_res
```

可以看到 p-value < 0.05，可以拒绝零假设，不同条件之间确实存在命运选择。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_1dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_1dpi)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | pnr2_cells,],
  conditions = sce_me_da_1dpi$treatment[mock_cells | pnr2_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | tr4_cells,],
  conditions = sce_me_da_1dpi$treatment[mock_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[pnr2_cells | tr4_cells,],
  conditions = sce_me_da_1dpi$treatment[pnr2_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

可以发现 PNR2 与 TR4 的命运选择的显著性 p-value 是最小的。

#### 基因动态表达

##### 特征选择

```{r}
# Fit GAM for all genes will take too much memory. So
# we select features based on two different methods. See
# https://github.com/statOmics/tradeSeq/issues/150
sce_me_da_1dpi <- scry::devianceFeatureSelection(sce_me_da_1dpi, assay = "logcounts", sorted = FALSE)
rowData(sce_me_da_1dpi)$geneVar <- scran::modelGeneVar(sce_me_da_1dpi, density.weights = FALSE)
hvg.vars <- scran::getTopHVGs(rowData(sce_me_da_1dpi)$geneVar, n = 5000)
sorted <- sort(rowData(sce_me_da_1dpi)$binomial_deviance, decreasing = TRUE)
hvg.dev <- names(sorted)[1:5000]
hvgs <- union(hvg.dev, hvg.vars)
```

> At any given abundance, we assume that the variation in expression for most genes is driven by uninteresting processes like sampling noise. Under this assumption, the fitted value of the trend at any given gene’s abundance represents an estimate of its uninteresting variation, which we call the technical component. We then define the biological component for each gene as the difference between its total variance and the technical component. This biological component represents the “interesting” variation for each gene and can be used as the metric for HVG selection.
>
> Strictly speaking, the interpretation of the fitted trend as the technical component assumes that the expression profiles of most genes are dominated by random technical noise. In practice, all expressed genes will exhibit some non-zero level of biological variability due to events like transcriptional bursting. Thus, it would be more appropriate to consider these estimates as technical noise plus “uninteresting” biological variation, under the assumption that most genes do not participate in the processes driving interesting heterogeneity across the population.

```{r fig.height=4, fig.width=10}
layout(matrix(c(1, 2), nrow = 1))

fit.var <- metadata(rowData(sce_me_da_1dpi)$geneVar)
plot(fit.var$mean, fit.var$var, xlab = "Mean of log-expression",
    ylab = "Variance of log-expression",
    main="Feature Selection with Variance")
points(fit.var$mean[hvg.dev], fit.var$var[hvg.dev], col = "red", pch = 16, cex = 0.5)
curve(fit.var$trend(x), col = "dodgerblue", add = TRUE, lwd = 2)

selected <- sorted * NA
selected[hvg.vars] <- sorted[hvg.vars]
plot(sorted, type="l", xlab="ranked genes",
     ylab="binomial deviance", main="Feature Selection with Deviance")
segments(
  x0 = seq_along(selected), y0 = 0,
  x1 = seq_along(selected), y1 = selected,
  lty = 1, lwd = 0.03)
abline(v = 5000, lty = 2, col = "red")
```

##### 参数优化

```{r}
icMat <- xfun::cache_rds(
  file = "icMat_me_da_1dpi.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = tradeSeq::evaluateK(sce_me_da_1dpi, k = 3:10)
)
```

```{r}
tradeSce <- xfun::cache_rds(
  file = "tradeseq_gam_me_da_1dpi.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = tradeSeq::fitGAM(
    # fitGAM needs counts rather than logcounts, see
    # the source code of SCE-version fitGAM.
    counts = sce_me_da_1dpi, nknots = 6,
    conditions = factor(sce_me_da_1dpi$treatment),
    sce = TRUE, verbose = TRUE,
    genes = hvgs
  )
)
```

感觉 Slingshot 的 pseudotime 计算的不好，头部和尾部的细胞分布太少了。

##### 差异表达

###### 谱系内的比较

> To assess significant changes in gene expression as a function of pseudotime within each lineage, we use the `associationTest`, which tests the null hypothesis that gene expression is not a function of pseudotime, i.e., whether the estimated smoothers are significantly varying as a function of pseudotime within each lineage.

```{r}
assocRes <- tradeSeq::associationTest(tradeSce, lineages = TRUE)
```

```{r}
lineage1_mockGenes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage1_conditionMOCK, "fdr") <= 0.05)
]

lineage1_pnr2Genes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage1_conditionPNR2, "fdr") <= 0.05)
]

lineage1_tr4Genes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage1_conditionTR4, "fdr") <= 0.05)
]

lineage2_mockGenes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage2_conditionMOCK, "fdr") <= 0.05)
]

lineage2_pnr2Genes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage2_conditionPNR2, "fdr") <= 0.05)
]

lineage2_tr4Genes <- rownames(assocRes)[
  which(p.adjust(assocRes$pvalue_lineage2_conditionTR4, "fdr") <= 0.05)
]

UpSetR::upset(
  data = UpSetR::fromList(list(
    Lineage1_MOCK = lineage1_mockGenes,
    Lineage1_PNR2 = lineage1_pnr2Genes,
    Lineage1_TR4 = lineage1_tr4Genes,
    Lineage2_MOCK = lineage2_mockGenes,
    Lineage2_PNR2 = lineage2_pnr2Genes,
    Lineage2_TR4 = lineage2_tr4Genes)),
  keep.order = TRUE)
```

###### 谱系间的比较

因为只有两条世系，所以 `pairwise = TRUE` 无用。

```{r}
patternRes <- tradeSeq::patternTest(tradeSce, global = TRUE)
patternGenes <- rownames(patternRes)[which(p.adjust(patternRes$pvalue, "fdr") <= 0.05)]
```

关于 `tradeSeq::predictSmooth()` 的参数：

> `nPoints`: The number of points used to create the grid along the smoother for each lineage. 

```{r fig.height=7, fig.width=14}
diffGenes <- Reduce(union, list(
  lineage1_mockGenes, lineage1_pnr2Genes, lineage1_tr4Genes,
  lineage2_mockGenes, lineage2_pnr2Genes, lineage2_tr4Genes,
  patternGenes))
yhatSmooth <- tradeSeq::predictSmooth(tradeSce, gene = diffGenes, nPoints = 100, tidy = FALSE)
yhatSmoothScaled <- t(scale(t(yhatSmooth)))

ph_res <- plotPseudotimeHeatmap(
  yhatSmoothScaled,
  #palette = colorRamps::matlab.like,
  seriation = FALSE,
  dend_k = 8,
  row_title = "G%s",
  row_title_rot = 0,
  column_split = stringr::str_match(
    colnames(yhatSmoothScaled), "(lineage\\d)_condition(.*)_")[, 2:3],
) |> ComplexHeatmap::draw()
```

```{r}
gene_list <- ComplexHeatmap::row_order(ph_res)
names(gene_list) <- paste0("G", 1:8)
gene_list <- lapply(gene_list, function(order) {
  rownames(yhatSmoothScaled)[order]
})
```

```{r}
comp_enr <- clusterProfiler::compareCluster(
  gene_list,
  fun = "enrichGO",
  OrgDb = org.Taestivum.iwgsc.db,
  keyType = "GID",
  ont = "BP",
  universe = rownames(tradeSce)
) |> clusterProfiler::simplify(cutoff = 0.4)
```

```{r fig.height=8, fig.width=6}
enrichplot::dotplot(
    comp_enr, showCategory = 10, by = "count", label_format = 100)
```

###### 条件间的比较

> To test differential expression between conditions, we use the `conditionTest` function implemented in `tradeSeq`. This function tests the null hypothesis that genes have identical expression patterns in each condition

可以探索下 `pairwise` 和 `lineages` 两个参数。

```{r}
condRes <- tradeSeq::conditionTest(tradeSce, global = FALSE, pairwise = TRUE, lineages = TRUE)
```

```{r}
waldStat <- condRes |>
  dplyr::select(dplyr::starts_with("waldStat")) |>
  tibble::rownames_to_column(var = "gene") |>
  tidyr::pivot_longer(dplyr::starts_with("waldStat"),
                      names_to = c("lineage", "comparison"),
                      names_sep = "_",
                      names_prefix = "waldStat_",
                      values_to = "waldStat")

pvalue <- condRes |>
  dplyr::select(dplyr::starts_with("pvalue")) |>
  tibble::rownames_to_column(var = "gene") |>
  tidyr::pivot_longer(dplyr::starts_with("pvalue"),
                      names_to = c("lineage", "comparison"),
                      names_sep = "_",
                      names_prefix = "pvalue_",
                      values_to = "pvalue")

dof <- condRes |>
  dplyr::select(dplyr::starts_with("df")) |>
  tibble::rownames_to_column(var = "gene") |>
  tidyr::pivot_longer(dplyr::starts_with("df"),
                      names_to = c("lineage", "comparison"),
                      names_sep = "_",
                      names_prefix = "df_",
                      values_to = "dof")

condRes_df <- dplyr::full_join(waldStat, pvalue) |>
  dplyr::full_join(dof) |>
  dplyr::filter(!is.na(waldStat))

condRes_df <- condRes_df |>
  dplyr::group_by(lineage, comparison) |>
  tidyr::nest() |>
  dplyr::mutate(data = lapply(
    data, function(x) dplyr::mutate(
      x, fdr = p.adjust(pvalue, "fdr")))) |>
  tidyr::unnest(cols = c(data))

condRes_df
```


```{r}
dplyr::filter(condRes_df, fdr <= 0.01) |>
  dplyr::select(lineage, comparison, gene) |>
  dplyr::group_by(gene) |>
  tidyr::nest(data = c(lineage, comparison)) |>
  dplyr::mutate(
    diffcomp = lapply(data, function(df)
      purrr::pmap_chr(df, paste, sep = "_"))) |>
  ggplot2::ggplot(ggplot2::aes(x=diffcomp)) +
  ggplot2::geom_bar() +
  ggplot2::geom_text(stat = "count",
    ggplot2::aes(label = ggplot2::after_stat(count)),
    vjust = -1, size = 3) +
  cowplot::theme_cowplot() +
  # ggupset will set theme for combmatrix, so put
  # theme_cowplot abouve.
  ggupset::scale_x_upset(n_intersections = 20, order_by = "degree") +
  ggplot2::scale_y_continuous(
    expand = ggplot2::expansion(add = c(0, 60))) +
  NULL
```

```{r}
conditionGenes <- dplyr::filter(condRes_df, fdr <= 0.01) |>
  dplyr::pull("gene") |> unique()
```

```{r fig.height=7, fig.width=14}
### based on mean smoother
yhatSmooth <- tradeSeq::predictSmooth(
  tradeSce, gene = conditionGenes, nPoints = 300, tidy = FALSE)
yhatSmoothScaled <- t(scale(t(yhatSmooth)))

ph_res <- plotPseudotimeHeatmap(
  yhatSmoothScaled, 
  #palette = colorRamps::matlab.like,
  seriation = FALSE,
  dend_k = 8,
  row_title = "G%s",
  row_title_rot = 0,
  column_split = stringr::str_match(
    colnames(yhatSmoothScaled), "(lineage\\d)_condition(.*)_")[, 2:3],
) |> ComplexHeatmap::draw()
```

```{r}
gene_list <- ComplexHeatmap::row_order(ph_res)
names(gene_list) <- paste0("G", 1:8)
gene_list <- lapply(gene_list, function(order) {
  rownames(yhatSmoothScaled)[order]
})
```

```{r}
comp_enr <- clusterProfiler::compareCluster(
  gene_list,
  fun = "enrichGO",
  OrgDb = org.Taestivum.iwgsc.db,
  keyType = "GID",
  ont = "BP",
  universe = rownames(tradeSce)
) |> clusterProfiler::simplify(cutoff = 0.4)
```

```{r fig.height=8, fig.width=6}
enrichplot::dotplot(
    comp_enr, showCategory = 10, by = "count", label_format = 100)
```

```{r}
rm(sce_1dpi, sce_me_da_1dpi)
gc()
```


## 2 差异轨迹分析 2DPI 样本

```{r}
sce_2dpi <- sce[, sce$time == "2DPI"]
```

### 2.1 整体分析

#### 降维可视化 {.tabset}

```{r}
sce_2dpi <- runDiffusionMap(sce_2dpi, dimred = "HARMONY")
sce_2dpi <- runPHATE(sce_2dpi, dimred = "HARMONY")
```

##### t-SNE

```{r}
scater::plotReducedDim(sce_2dpi, dimred = "TSNE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### UMAP

```{r}
scater::plotReducedDim(sce_2dpi, dimred = "UMAP",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PHATE

```{r}
scater::plotReducedDim(sce_2dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### 细胞种群连接性

```{r}
adata_2dpi <- readPickle(Sys.glob(
  "../results/ObjectCache/TrajectoryInference/scvelo_adata_2dpi_*.pickle"))
```

```{r}
adata_2dpi$obsm$update(list(
  X_tsne = reducedDim(sce_2dpi, "TSNE"),
  X_umap = reducedDim(sce_2dpi, "UMAP"),
  X_phate = reducedDim(sce_2dpi, "PHATE")
))

adata_2dpi$obs$cellType <- sce_2dpi$cluster_id
```

```{r}
sc$tl$paga(adata_2dpi, groups='cellType')
```

```{r fig.height=7, fig.width=14}
p1 <- plotPagaGraph(adata_2dpi, basis="tsne", threshold = 0.3) +
  ggplot2::coord_fixed()
p2 <- plotPagaGraph(adata_2dpi, basis="umap", threshold = 0.3) +
  ggplot2::coord_fixed()

p1 + p2
```

### 2.2 叶肉细胞世系

```{r}
cells_chosen <- sce_2dpi$cluster_id %in% c(
  "Me_1", "Me_2", "Me_4", "Me_3", "Va_1")
sce_me_da_2dpi <- sce_2dpi[, cells_chosen]
sce_me_da_2dpi <- sce_me_da_2dpi[
  Matrix::rowSums(counts(sce_me_da_2dpi) > 0) > 10, ]
```

#### 降维可视化 {.tabset}

```{r}
sce_me_da_2dpi <- scater::runUMAP(sce_me_da_2dpi, dimred = "HARMONY", ncomponents = 30L)
sce_me_da_2dpi <- runDiffusionMap(sce_me_da_2dpi, dimred = "HARMONY")
sce_me_da_2dpi <- runPHATE(sce_me_da_2dpi, dimred = "HARMONY")
```

##### HARMONY

```{r}
scater::plotReducedDim(sce_me_da_2dpi,
    dimred = "HARMONY",
    ncomponents = c(7, 17),
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PAHTE

```{r}
scater::plotReducedDim(sce_me_da_2dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

从 PHATE 图看，Va_1 确实深度参与了叶肉细胞世系的形成。

##### DiffusionMap

```{r}
scater::plotReducedDim(sce_me_da_2dpi, dimred = "DiffusionMap",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_2dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### RNA 速率

```{r}
adata_me_da_2dpi <- cache_pickle(
  file = "scvelo_me_da_2dpi.pickle",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = runScVelo(
    sce_me_da_2dpi,
    mode = "dynamical",
    use.dimred = "HARMONY",
    assay.X = "logcounts",
    scvelo.params = list(
      filter_and_normalize = list(
        min_shared_counts = 20L, n_top_genes = 2000L),
      moments = list(n_pcs = 30L, n_neighbors = 30L)
    )
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata_me_da_2dpi$obsm$update(list(
  X_tsne = reducedDim(sce_me_da_2dpi, "TSNE"),
  X_umap = reducedDim(sce_me_da_2dpi, "UMAP")
))

adata_me_da_2dpi$obs$cellType <- as.character(sce_me_da_2dpi$cluster_id)
```

```{python fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata_me_da_2dpi, basis="umap", color="cellType", figsize = (7, 7))
```

#### 轨迹推断

```{r}
sce_me_da_2dpi <- xfun::cache_rds(
  file = "slingshot_me_da_2dpi.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = slingshot::slingshot(sce_me_da_2dpi,
    clusterLabels = sce_me_da_2dpi$cluster_id,
    reducedDim = "UMAP", approx_points = 500,
    start.clus = "Me_4", end.clus = c("Me_1", "Me_2"))
)
```

##### 细胞世系 {.tabset}

###### HARMONY

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_2dpi, dimred = "HARMONY", ncomponents = c(7, 17))
```

###### DiffusionMap

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_2dpi, dimred = "DiffusionMap")
```

###### PHATE

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_2dpi, dimred = "PHATE")
```

##### 拟时间分布

```{r fig.height=3, fig.width=7}
psts <- slingshot::slingPseudotime(sce_me_da_2dpi) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages, scales = "free_x") +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

#### 差异进程分析

```{r}
psts <- slingshot::slingPseudotime(sce_me_da_2dpi$slingshot) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_2dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "pseudotime", names_to = "lineages")
```

```{r fig.height=3, fig.width=7}
ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = conditions)) +
    ggplot2::geom_density(alpha = .5) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_wrap(~lineages, scales = "free_x") +
    cowplot::theme_cowplot() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white")
    )
```

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_2dpi, dimred = "PHATE")
```

```{r fig.height=4, fig.width=13}
p1 <- scater::plotReducedDim(
    sce_me_da_2dpi, dimred = "PHATE", colour_by = "cellType") +
  ggplot2::coord_fixed()

p2 <- scater::plotReducedDim(
    sce_me_da_2dpi, dimred = "PHATE", colour_by = "treatment") +
  ggplot2::coord_fixed()

p1 + p2
```


##### 差异拓扑

> Test whether or not slingshot should be fitted independently for different conditions or not. The null hypothesis that a common trajectory should be fitted.

```{r}
top_res <- condiments::topologyTest(
  sds = sce_me_da_2dpi$slingshot,
  conditions = sce_me_da_2dpi$treatment,
  methods = "Classifier",
  threshs = 0.05)
```

```{r}
top_res
```


##### 差异进程

```{r}
prog_res  <- condiments::progressionTest(
  pseudotime = sce_me_da_2dpi,
  conditions = sce_me_da_2dpi$treatment,
  lineages = TRUE, method = "KS")
```

```{r}
prog_res
```

上面这个用的是 Classifier ，但我们想要是 condition 之间的两两比较。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_2dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_2dpi)
mock_cells <- sce_me_da_2dpi$treatment == "MOCK"
pnr2_cells <- sce_me_da_2dpi$treatment == "PNR2"
tr4_cells <- sce_me_da_2dpi$treatment == "TR4"
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[pnr2_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[pnr2_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[pnr2_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[pnr2_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[pnr2_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[pnr2_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
```

##### 差异命运选择

> The distribution has tri modes, which is very often the case for two lineages.
> - Weight around 0 represent a cell that is mostly assigned to the other lineage.
> - Weight around .5 represent a cell that is equally assigned to both lineages.
> - Weight around 1 represent a cell that is mostly assigned to this lineage.
> However, it is important to note that the sum of all lineage weights should sum to 1. As such, we can only plot the weights for the first lineage.

```{r fig.height=3, fig.width=7}
ws <- slingshot::slingCurveWeights(sce_me_da_2dpi$slingshot, as.probs = TRUE) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_2dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "weight", names_to = "lineages")

ggplot2::ggplot(ws, ggplot2::aes(x = weight, fill = conditions)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages) +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```


> Test whether or not the cell repartition between lineages is independent of the conditions

因为我们这里只有两个世系，所有 `pairwise=TRUE` 没啥意义。

```{r}
dif_res <- condiments::fateSelectionTest(
  cellWeights = sce_me_da_2dpi$slingshot,
  conditions = sce_me_da_2dpi$treatment,
  global = FALSE, pairwise = FALSE)
```

```{r}
dif_res
```

可以看到 p-value < 0.05，可以拒绝零假设，不同条件之间确实存在命运选择。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_2dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_2dpi)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | pnr2_cells,],
  conditions = sce_me_da_2dpi$treatment[mock_cells | pnr2_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | tr4_cells,],
  conditions = sce_me_da_2dpi$treatment[mock_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[pnr2_cells | tr4_cells,],
  conditions = sce_me_da_2dpi$treatment[pnr2_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

可以发现 PNR2 与 TR4 的命运选择的显著性 p-value 是最小的。

```{r}
rm(sce_2dpi, sce_me_da_2dpi)
gc()
```

## 3 差异轨迹分析 3DPI 样本

```{r}
sce_3dpi <- sce[, sce$time == "3DPI"]
```

### 3.1 整体分析

#### 降维可视化 {.tabset}

```{r}
sce_3dpi <- runDiffusionMap(sce_3dpi, dimred = "HARMONY")
sce_3dpi <- runPHATE(sce_3dpi, dimred = "HARMONY")
```

##### t-SNE

```{r}
scater::plotReducedDim(sce_3dpi, dimred = "TSNE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### UMAP

```{r}
scater::plotReducedDim(sce_3dpi, dimred = "UMAP",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PHATE

```{r}
scater::plotReducedDim(sce_3dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### 细胞种群连接性

```{r}
adata_3dpi <- readPickle(Sys.glob(
  "../results/ObjectCache/TrajectoryInference/scvelo_adata_3dpi_*.pickle"))
```

```{r}
adata_3dpi$obsm$update(list(
  X_tsne = reducedDim(sce_3dpi, "TSNE"),
  X_umap = reducedDim(sce_3dpi, "UMAP"),
  X_phate = reducedDim(sce_3dpi, "PHATE")
))

adata_3dpi$obs$cellType <- sce_3dpi$cluster_id
```

```{r}
sc$tl$paga(adata_3dpi, groups='cellType')
```

```{python fig.height=7, fig.width=14}
sc.pl.paga_compare(
    r.adata_3dpi, basis='umap', threshold=0.03, title='',
    right_margin=0.2, size=10, edge_width_scale=0.5,
    legend_fontsize=12, fontsize=12, frameon=False, edges=True, show=True)
```

```{r fig.height=7, fig.width=14}
p1 <- plotPagaGraph(adata_3dpi, basis="tsne", threshold = 0.3) +
  ggplot2::coord_fixed()
p2 <- plotPagaGraph(adata_3dpi, basis="umap", threshold = 0.3) +
  ggplot2::coord_fixed()

p1 + p2
```

### 3.2 叶肉细胞世系

```{r}
cells_chosen <- sce_3dpi$cluster_id %in% c(
  "Me_1", "Me_2", "Me_4", "Me_3", "Va_1")
sce_me_da_3dpi <- sce_3dpi[, cells_chosen]
sce_me_da_3dpi <- sce_me_da_3dpi[
  Matrix::rowSums(counts(sce_me_da_3dpi) > 0) > 10, ]
```

#### 降维可视化 {.tabset}

```{r}
sce_me_da_3dpi <- scater::runUMAP(sce_me_da_3dpi, dimred = "HARMONY", ncomponents = 30L)
sce_me_da_3dpi <- runDiffusionMap(sce_me_da_3dpi, dimred = "HARMONY")
sce_me_da_3dpi <- runPHATE(sce_me_da_3dpi, dimred = "HARMONY")
```

##### HARMONY

```{r}
scater::plotReducedDim(sce_me_da_3dpi,
    dimred = "HARMONY",
    ncomponents = c(7, 17),
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PAHTE

```{r}
scater::plotReducedDim(sce_me_da_3dpi, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

从 PHATE 图看，Va_1 确实深度参与了叶肉细胞世系的形成。

##### DiffusionMap

```{r}
scater::plotReducedDim(sce_me_da_3dpi, dimred = "DiffusionMap",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_da_3dpi$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### RNA 速率

```{r}
adata_me_da_3dpi <- cache_pickle(
  file = "scvelo_me_da_3dpi.pickle",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = runScVelo(
    sce_me_da_3dpi,
    mode = "dynamical",
    use.dimred = "HARMONY",
    assay.X = "logcounts",
    scvelo.params = list(
      filter_and_normalize = list(
        min_shared_counts = 20L, n_top_genes = 2000L),
      moments = list(n_pcs = 30L, n_neighbors = 30L)
    )
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata_me_da_3dpi$obsm$update(list(
  X_tsne = reducedDim(sce_me_da_3dpi, "TSNE"),
  X_umap = reducedDim(sce_me_da_3dpi, "UMAP")
))

adata_me_da_3dpi$obs$cellType <- as.character(sce_me_da_3dpi$cluster_id)
```

```{python fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata_me_da_3dpi, basis="umap", color="cellType", figsize = (7, 7))
```

#### 轨迹推断

同时指定多个 `end.clus` 强迫 slingshot 对 3DPI 数据集拟合两条轨迹。

```{r}
sce_me_da_3dpi <- xfun::cache_rds(
  file = "slingshot_me_da_3dpi.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = slingshot::slingshot(sce_me_da_3dpi,
    clusterLabels = sce_me_da_3dpi$cluster_id,
    reducedDim = "UMAP", approx_points = 500,
    start.clus = "Me_4", end.clus = c("Me_1", "Me_2"))
)
```

##### 细胞世系 {.tabset}

###### HARMONY

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_3dpi, dimred = "HARMONY", ncomponents = c(7, 17))
```

###### DiffusionMap

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_da_3dpi, dimred = "DiffusionMap")
```

###### PHATE

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_3dpi, dimred = "PHATE")
```

###### UMAP

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_3dpi, dimred = "TSNE")
```

##### 拟时间分布

```{r fig.height=3, fig.width=7}
psts <- slingshot::slingPseudotime(sce_me_da_3dpi) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages, scales = "free_x") +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

#### 差异进程分析

```{r}
psts <- slingshot::slingPseudotime(sce_me_da_3dpi$slingshot) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_3dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "pseudotime", names_to = "lineages")
```

```{r fig.height=3, fig.width=7}
ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = conditions)) +
    ggplot2::geom_density(alpha = .5) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_wrap(~lineages, scales = "free_x") +
    cowplot::theme_cowplot() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white")
    )
```

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_da_3dpi, dimred = "PHATE")
```

```{r fig.height=4, fig.width=13}
p1 <- scater::plotReducedDim(
    sce_me_da_3dpi, dimred = "PHATE", colour_by = "cellType") +
  ggplot2::coord_fixed()

p2 <- scater::plotReducedDim(
    sce_me_da_3dpi, dimred = "PHATE", colour_by = "treatment") +
  ggplot2::coord_fixed()

p1 + p2
```

```{r}
rm(sce_3dpi, sce_me_da_3dpi)
gc()
```

```{r}
knitr::knit_exit()
```


##### 差异拓扑

> Test whether or not slingshot should be fitted independently for different conditions or not. The null hypothesis that a common trajectory should be fitted.

```{r}
top_res <- condiments::topologyTest(
  sds = sce_me_da_3dpi$slingshot,
  conditions = sce_me_da_3dpi$treatment,
  methods = "Classifier",
  threshs = 0.05)
```

```{r}
top_res
```


##### 差异进程

```{r}
prog_res  <- condiments::progressionTest(
  pseudotime = sce_me_da_3dpi,
  conditions = sce_me_da_3dpi$treatment,
  lineages = TRUE, method = "KS")
```

```{r}
prog_res
```

上面这个用的是 Classifier ，但我们想要是 condition 之间的两两比较。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_3dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_3dpi)
mock_cells <- sce_me_da_3dpi$treatment == "MOCK"
pnr2_cells <- sce_me_da_3dpi$treatment == "PNR2"
tr4_cells <- sce_me_da_3dpi$treatment == "TR4"
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[pnr2_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[pnr2_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[mock_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage1"], y = pst[tr4_cells, "Lineage1"],
  w_x = ws[pnr2_cells, "Lineage1"], w_y = ws[tr4_cells, "Lineage1"])
```

```{r}
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[pnr2_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[pnr2_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[mock_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[mock_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
Ecume::ks_test(
  x = pst[pnr2_cells, "Lineage2"], y = pst[tr4_cells, "Lineage2"],
  w_x = ws[pnr2_cells, "Lineage2"], w_y = ws[tr4_cells, "Lineage2"])
```

##### 差异命运选择

> The distribution has tri modes, which is very often the case for two lineages.
> - Weight around 0 represent a cell that is mostly assigned to the other lineage.
> - Weight around .5 represent a cell that is equally assigned to both lineages.
> - Weight around 1 represent a cell that is mostly assigned to this lineage.
> However, it is important to note that the sum of all lineage weights should sum to 1. As such, we can only plot the weights for the first lineage.

```{r fig.height=3, fig.width=7}
ws <- slingshot::slingCurveWeights(sce_me_da_3dpi$slingshot, as.probs = TRUE) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_da_3dpi$treatment) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "weight", names_to = "lineages")

ggplot2::ggplot(ws, ggplot2::aes(x = weight, fill = conditions)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages) +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```


> Test whether or not the cell repartition between lineages is independent of the conditions

因为我们这里只有两个世系，所有 `pairwise=TRUE` 没啥意义。

```{r}
dif_res <- condiments::fateSelectionTest(
  cellWeights = sce_me_da_3dpi$slingshot,
  conditions = sce_me_da_3dpi$treatment,
  global = FALSE, pairwise = FALSE)
```

```{r}
dif_res
```

可以看到 p-value < 0.05，可以拒绝零假设，不同条件之间确实存在命运选择。

```{r}
pst <- slingshot::slingPseudotime(sce_me_da_3dpi)
ws <- slingshot::slingCurveWeights(sce_me_da_3dpi)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | pnr2_cells,],
  conditions = sce_me_da_3dpi$treatment[mock_cells | pnr2_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[mock_cells | tr4_cells,],
  conditions = sce_me_da_3dpi$treatment[mock_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
condiments::fateSelectionTest(
  cellWeights = ws[pnr2_cells | tr4_cells,],
  conditions = sce_me_da_3dpi$treatment[pnr2_cells | tr4_cells],
  global = FALSE, pairwise = FALSE)
```

```{r}
rm(sce_3dpi, sce_me_da_3dpi)
gc()
```

## 4 时间整合分析

### 4.1 叶肉细胞世系

是否要正对不同 condition 拟合不同的轨迹？参考下面 KRAS 教程试试，另外 Fibrosis 教程通过排除一个 cellType 也避免了拟合不同轨迹，还比较了两个选择间的不同。

- https://hectorrdb.github.io/condimentsPaper/articles/KRAS.html
- https://hectorrdb.github.io/condimentsPaper/articles/Fibrosis.html


```{r}
cells_chosen <- sce$cluster_id %in% c(
  "Me_1", "Me_2", "Me_4", "Me_3", "Va_1")
sce_me_all <- sce[, cells_chosen]
sce_me_all <- sce_me_all[
  Matrix::rowSums(counts(sce_me_all) > 0) > 10, ]
```

#### 降维可视化 {.tabset}

```{r}
sce_me_all <- scater::runUMAP(sce_me_all, dimred = "HARMONY", ncomponents = 30L)
sce_me_all <- runDiffusionMap(sce_me_all, dimred = "HARMONY")
sce_me_all <- runPHATE(sce_me_all, dimred = "HARMONY")
```

##### HARMONY

```{r}
scater::plotReducedDim(sce_me_all,
    dimred = "HARMONY",
    ncomponents = c(7, 17),
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_all$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### PAHTE

```{r}
scater::plotReducedDim(sce_me_all, dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_all$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

从 PHATE 图看，Va_1 确实深度参与了叶肉细胞世系的形成。

##### DiffusionMap

```{r}
scater::plotReducedDim(sce_me_all, dimred = "DiffusionMap",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::scale_color_manual(
    values = Seurat::DiscretePalette(
      length(unique(sce_me_all$cellType)))
  ) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### RNA 速率

```{r}
adata_me_all <- cache_pickle(
  file = "scvelo_me_all.pickle",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = runScVelo(
    sce_me_all,
    mode = "dynamical",
    use.dimred = "HARMONY",
    assay.X = "logcounts",
    scvelo.params = list(
      filter_and_normalize = list(
        min_shared_counts = 20L, n_top_genes = 2000L),
      moments = list(n_pcs = 30L, n_neighbors = 30L)
    )
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata_me_all$obsm$update(list(
  X_tsne = reducedDim(sce_me_all, "TSNE"),
  X_umap = reducedDim(sce_me_all, "UMAP")
))

adata_me_all$obs$cellType <- as.character(sce_me_all$cluster_id)
```

```{python fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata_me_all, basis="umap", color="cellType", figsize = (7, 7))
```

#### 轨迹推断

```{r}
sce_me_all <- xfun::cache_rds(
  file = "slingshot_me_all.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = slingshot::slingshot(sce_me_all,
    clusterLabels = sce_me_all$cluster_id,
    reducedDim = "UMAP", start.clus = "Me_1",
    approx_points = 500)
)
```

##### 细胞世系 {.tabset}

###### HARMONY

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_all, dimred = "HARMONY", ncomponents = c(7, 17))
```

###### DiffusionMap

```{r fig.height=6, fig.width=12}
plotLineagesOnReduc(sce_me_all, dimred = "DiffusionMap")
```

###### PHATE

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_all, dimred = "PHATE")
```

###### UMAP

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_all, dimred = "TSNE")
```

##### 拟时间分布

```{r fig.height=3, fig.width=7}
psts <- slingshot::slingPseudotime(sce_me_all) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages, scales = "free_x") +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

```{r}
psts <- slingshot::slingPseudotime(sce_me_all$slingshot) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_me_all$treatment,
    time = sce_me_all$time) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "pseudotime", names_to = "lineages")
```

```{r fig.height=3, fig.width=7}
dplyr::filter(psts, !is.na(pseudotime)) |>
ggplot2::ggplot(ggplot2::aes(x = pseudotime, fill = conditions)) +
    #ggplot2::geom_density(alpha = .5) +
    ggridges::geom_density_ridges(ggplot2::aes(y = conditions), scale = 4) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_grid(lineages~time, scales = "free_x") +
    ggridges::theme_ridges() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white"))
```

```{r fig.height=3, fig.width=7}
dplyr::filter(psts, !is.na(pseudotime)) |>
ggplot2::ggplot(ggplot2::aes(x = pseudotime, fill = conditions)) +
    ggplot2::geom_density(alpha = .5) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_grid(lineages~time, scales = "free_x") +
    ggridges::theme_ridges() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white"))
```

```{r fig.height=5, fig.width=14}
plotLineagesOnReduc(sce_me_all, dimred = "PHATE")
```

```{r fig.height=4, fig.width=13}
p1 <- scater::plotReducedDim(
    sce_me_all, dimred = "PHATE", colour_by = "cellType") +
  ggplot2::coord_fixed()

p2 <- scater::plotReducedDim(
    sce_me_all, dimred = "PHATE", colour_by = "treatment") +
  ggplot2::coord_fixed()

p1 + p2
```

#### 差异进程分析

##### 差异拓扑

> Test whether or not slingshot should be fitted independently for different conditions or not. The null hypothesis that a common trajectory should be fitted.

```{r}
top_res <- condiments::topologyTest(
  sds = sce_me_all$slingshot,
  conditions = sce_me_all$treatment,
  methods = "Classifier",
  threshs = 0.05)
```

```{r}
top_res
```

很明显，不同 conditions 之间应该拟合不同的轨迹。

##### 轨迹拆分

```{r}
sdss <- condiments::slingshot_conditions(
  sce_me_all, sce_me_all$treatment, approx_points = 500,
  extend = "n", reweight = FALSE, reassign = FALSE)

sdss$condition_id <- names(sdss)
sdss$mapping <- matrix(rep(1:2, each = 3), nrow = 2, ncol = 3, byrow = TRUE)
sds <- do.call(condiments::merge_sds, sdss)
```

### 4.2 外鞘世系

```{r}
cells_chosen <- sce$cluster_id %in% c(
  "Me_4", "Me_5", "Me_6", "Va_2", "Va_3", "Va_4")
sce_os_all <- sce[, cells_chosen]
sce_os_all <- sce_os_all[
  Matrix::rowSums(counts(sce_os_all) > 0) > 10, ]
```

#### 降维可视化 {.tabset}

```{r}
sce_os_all <- scater::runUMAP(sce_os_all, dimred = "HARMONY", ncomponents = 30L)
sce_os_all <- runDiffusionMap(sce_os_all, dimred = "HARMONY", seed = 1201, ncomponents = 2, n_eigs = 2)
sce_os_all <- runPHATE(sce_os_all, dimred = "HARMONY", seed = 1201, knn = 15, t = 30)
```

##### PHATE

```{r}
scater::plotReducedDim(
    sce_os_all,
    dimred = "PHATE",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

##### DiffusionMap

```{r}
sce_os_all$cellType <- droplevels(sce_os_all$cellType)
```

```{r}
scater::plotReducedDim(
    sce_os_all,
    dimred = "DiffusionMap",
    point_size = 0.5,
    colour_by = "cellType",
    text_by = "cellType",
    text_size = 3) +
  ggplot2::guides(color = ggplot2::guide_legend(
    override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

#### 轨迹推断

```{r}
sce_os_all <- xfun::cache_rds(
  file = "slingshot_os_all.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = slingshot::slingshot(sce_os_all,
    clusterLabels = sce_os_all$cluster_id,
    reducedDim = "UMAP", start.clus = "Me_4",
    approx_points = 500)
)
```

##### 细胞世系 {.tabset}

###### PHATE

```{r fig.height=10, fig.width=12}
plotLineagesOnReduc(sce_os_all, dimred = "PHATE",
                    path_size = 1, point_size = 0.5,
                    text_by = "cellType") +
  patchwork::plot_layout(ncol = 2)
```

###### DiffusionMap

```{r fig.height=7, fig.width=12}
plotLineagesOnReduc(sce_os_all, dimred = "DiffusionMap",
                    path_size = 1, point_size = 0.5,
                    text_by = "cellType") +
  patchwork::plot_layout(ncol = 3)
```


```{r}
plotLineageCurveOnReduc(sce_os_all, 1, dimred = "DiffusionMap",
                        point_size = 0.5, text_by = "cellType", text_size = 3) +
  ggplot2::ggtitle("Lineage1") +
  ggplot2::coord_fixed()
```

```{r}
plotLineageCurveOnReduc(sce_os_all, 2, dimred = "DiffusionMap",
                        point_size = 0.5, text_by = "cellType", text_size = 3) +
  ggplot2::ggtitle("Lineage2") +
  ggplot2::coord_fixed()
```

```{r}
plotLineageCurveOnReduc(sce_os_all, 3, dimred = "DiffusionMap",
                        point_size = 0.5, text_by = "cellType", text_size = 3) +
  ggplot2::ggtitle("Lineage3") +
  ggplot2::coord_fixed()
```

##### 拟时间分布

```{r fig.height=3, fig.width=7}
psts <- slingshot::slingPseudotime(sce_os_all) |>
  as.data.frame() |>
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      values_to = "pseudotime", names_to = "lineages")

ggplot2::ggplot(psts, ggplot2::aes(x = pseudotime, fill = lineages)) +
  ggplot2::geom_density(alpha = .5) +
  ggplot2::scale_fill_brewer(type = "qual") +
  ggplot2::facet_wrap(~lineages, scales = "free_x") +
  cowplot::theme_cowplot() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white")
  )
```

```{r}
psts <- slingshot::slingPseudotime(sce_os_all$slingshot) %>%
  as.data.frame() %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_os_all$treatment,
    time = sce_os_all$time,
    cellType = sce_os_all$cellType) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
    values_to = "pseudotime", names_to = "lineages")
```

```{r fig.height=3, fig.width=7}
dplyr::filter(psts, !is.na(pseudotime)) |>
ggplot2::ggplot(ggplot2::aes(x = pseudotime, fill = conditions)) +
    #ggplot2::geom_density(alpha = .5) +
    ggridges::geom_density_ridges(ggplot2::aes(y = conditions), scale = 4) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_grid(lineages~time, scales = "free_x") +
    ggridges::theme_ridges() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white"))
```

```{r fig.height=3, fig.width=7}
dplyr::filter(psts, !is.na(pseudotime)) |>
ggplot2::ggplot(ggplot2::aes(x = pseudotime, fill = conditions)) +
    ggplot2::geom_density(alpha = .5) +
    ggplot2::scale_fill_brewer(type = "qual") +
    ggplot2::facet_grid(lineages~time, scales = "free_x") +
    ggridges::theme_ridges() +
    ggplot2::theme(
      strip.background = ggplot2::element_rect(fill = "white"))
```

```{r}
psts <- slingshot::slingPseudotime(sce_os_all$slingshot)
colnames(psts) <- paste0(colnames(psts), "_pseudotime")
cwts <- slingshot::slingCurveWeights(sce_os_all$slingshot)
colnames(cwts) <- paste0(colnames(cwts), "_curveweights")

curve_data <- as.data.frame(cbind(psts, cwts)) %>%
  dplyr::mutate(
    cells = rownames(.),
    conditions = sce_os_all$treatment,
    time = sce_os_all$time,
    cellType = sce_os_all$cellType) %>%
  tidyr::pivot_longer(dplyr::starts_with("Lineage"),
                      names_to = c("lineages", "type"),
                      names_sep = "_",
                      values_to = "value") %>%
  tidyr::pivot_wider(names_from = type, values_from = value)
```

```{r fig.height=3, fig.width=7}
dplyr::filter(curve_data, !is.na(pseudotime)) |>
ggplot2::ggplot(ggplot2::aes(x = pseudotime, color = cellType)) +
  ggplot2::geom_jitter(ggplot2::aes(
    y = forcats::fct_reorder(cellType, pseudotime, .desc = TRUE),
    alpha = curveweights)) +
  ggplot2::ylab("cellType") +
  ggthemes::scale_color_tableau() +
  ggplot2::facet_wrap(~lineages, scales = "free_x", ncol = 3) +
  ggridges::theme_ridges() +
  ggplot2::theme(
    strip.background = ggplot2::element_rect(fill = "white"))
```

