---
title: "Developmental Process of MOCK Samples"
author: "Altair Wei"
date: '2022-10-05'
output: html_document
---

```{r setup, include=FALSE}
library(SingleCellExperiment)
knitr::opts_chunk$set(echo = TRUE)
source("../scripts/TrajectoryUtilities.R")
plt <- reticulate::import("matplotlib.pyplot")
scv <- reticulate::import("scvelo")
```

```{python}
import scvelo as scv
import matplotlib.pyplot as plt
import scanpy as sc
```

```{r message=FALSE, warning=FALSE, results="hide"}
library(org.Taestivum.iwgsc.db)
orgdb <- org.Taestivum.iwgsc.db
```

## 1 准备数据集

```{r}
samples <- c(
  "0DPI-MOCK-1",
  "0DPI-MOCK-2",
  "1DPI-MOCK-1",
  "1DPI-MOCK-2",
  "2DPI-MOCK-1",
  "2DPI-MOCK-2",
  "3DPI-MOCK-1",
  "3DPI-MOCK-2"
)

data_folders <- structure(
  paste0("../results/RawOutput/", samples), names = samples)

data_list <- xfun::cache_rds(
  file = "velocity_mock_data_list.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = lapply(data_folders, function(base_dir) {
    loom_file = paste0(base_dir, "/Velocyto/", basename(base_dir), ".loom")
    SeuratWrappers::ReadVelocity(loom_file)
   })
)
```

```{r}
fixCellNames <- function(mtx_list) {
  lapply(mtx_list, function(mtx) {
    colnames(mtx) <- colnames(mtx) |>
      stringr::str_sub(end = -2L) |>
      stringr::str_replace(stringr::fixed(":"), "_")
    mtx
  })
}

spliced <- xfun::cache_rds(
  file = "velocity_mock_mtx_spliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "spliced")))
)

unspliced <- xfun::cache_rds(
  file = "velocity_mock_mtx_unspliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "unspliced")))
)

ambiguous <- xfun::cache_rds(
  file = "velocity_mock_mtx_ambiguous.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = do.call(cbind, fixCellNames(lapply(data_list, "[[", "ambiguous")))
)
```

```{r}
obj_mock <- readRDS(Sys.glob(
  "../results/ObjectCache/IntegrationAndAnnotation/obj_mock_annotated_*.rds"))
```

```{r}
sce_mock <- xfun::cache_rds(
  file = "sce_mock_spliced.rds",
  dir = "../results/ObjectCache/TrajectoryInference/",
  expr = local({
    obj_mock$cellType <- Seurat::Idents(obj_mock)
    sce <- Seurat::as.SingleCellExperiment(obj_mock, assay = "RNA")
    sce <- muscat::prepSCE(sce,
      kid = "ident", # subpopulation assignments
      gid = "group", # group IDs (ctrl/stim)
      sid = "sample", # sample IDs (ctrl/stim.1234)
      drop = FALSE
    )

    cell_names <- colnames(sce)
    gene_names <- rownames(sce)
    assay(sce, "spliced") <- spliced[gene_names, cell_names]
    assay(sce, "unspliced") <- unspliced[gene_names, cell_names]

    sce
  })
)
```

## 2 降维分析 {.tabset}

```{r}
sce_mock <- runDiffusionMap(sce_mock, dimred = "HARMONY")
sce_mock <- runPHATE(sce_mock, dimred = "HARMONY")
```

### UMAP

```{r}
scater::plotUMAP(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### t-SNE

```{r}
scater::plotTSNE(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### DiffusionMap

```{r}
scater::plotDiffusionMap(sce_mock, colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

### PHATE

```{r}
scater::plotReducedDim(sce_mock, dimred = "PHATE", colour_by = "cluster_id", point_size = 0.5) +
  ggplot2::guides(color = ggplot2::guide_legend(override.aes = list(size = 2))) +
  ggplot2::coord_fixed()
```

## 3 共变邻域分析

```{r}
obj_mock$time_val <- as.numeric(factor(
  obj_mock$time, levels = c("0DPI", "1DPI", "2DPI", "3DPI")))

obj_mock <- rcna::association.Seurat(
  seurat_object = obj_mock,
  test_var = "time_val",
  samplem_key = "sample",
  graph_use = "RNA_nn",
  batches = NULL,
  covs = NULL
)
```

### 时间系列

```{r fig.height=3, fig.width=11}
Seurat::DimPlot(obj_mock, reduction = "umap", split.by = "time") &
  ggplot2::coord_fixed()
```

### 表型关联结果 {.tabset}

```{r}
blue_to_orange <- rev(ggthemes::ggthemes_data[[
  c("tableau", "color-palettes", "ordered-diverging", "Orange-Blue Diverging")]][["value"]])
```

在下面的图中，每个单元格根据其邻域系数着色，即颜色对应于每个细胞相应邻域的丰度与样本属性的相关性。由于我们将时间编码成了数字，因此从蓝色到橙红色代表了 0DPI \~ 3DPI 的邻域系数。

#### UMAP

```{r fig.height=8, fig.width=16}
p1 <- Seurat::FeaturePlot(obj_mock, reduction = "umap", features = c("cna_ncorrs")) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p2 <- Seurat::DimPlot(obj_mock, reduction = "umap", group = "group") &
  ggplot2::coord_fixed()

p1[[1]] + p2 + patchwork::plot_layout(nrow = 1)
```

#### t-SNE

```{r fig.height=8, fig.width=16}
p1 <- Seurat::FeaturePlot(obj_mock, reduction = "tsne", features = c("cna_ncorrs")) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p2 <- Seurat::DimPlot(obj_mock, reduction = "tsne", group = "group") &
  ggplot2::coord_fixed()

p1[[1]] + p2 + patchwork::plot_layout(nrow = 1)
```

### Neighborhood loadings of NAM PCs

查看源代码可知，`NAM_nbhdXpc` 等于 `NAM_embeddings`，而 `NAM_sampleXpc` 等于 `NAM_loadings` 。

```{r fig.height=8, fig.width=14}
p <- Seurat::FeaturePlot(
    obj_mock, reduction = "umap",
    features = paste0("NAMPC_", 1:6),
    ncol = 3, order = TRUE) &
  ggplot2::scale_color_gradientn(colours = blue_to_orange) &
  ggplot2::coord_fixed()

p
```

### Variance explained by NAM PCs

```{r}
data.frame(
  sig2 = obj_mock@reductions$cna@misc$NAM_svs
          / sum(obj_mock@reductions$cna@misc$NAM_svs)) |>
    tibble::rowid_to_column('PC') |>
    ggplot2::ggplot(ggplot2::aes(PC, sig2)) + 
        ggplot2::geom_point() + 
        ggplot2::geom_line() + 
        ggplot2::theme_classic(base_size = 14) + 
        ggplot2::labs(y = 'Fraction of variance explained', x = 'NAM PC') + 
        ggplot2::scale_x_continuous(breaks = 1:20)
```

### Per-gene correlations to neighborhood coefficient

```{r}
ncorrs <- as(matrix(obj_mock$cna_ncorrs, ncol = 1), "dgCMatrix")
genes <- qlcMatrix::corSparse(ncorrs, t(obj_mock@assays$RNA@counts))
genes <- structure(as.numeric(genes), names = rownames(obj_mock@assays$RNA@counts))
genes <- sort(genes, decreasing = TRUE)
```

```{r}
gsea <- clusterProfiler::gseGO(
  genes,
  ont = "BP",
  OrgDb = org.Taestivum.iwgsc.db,
  keyType = "GID"
)

gsea <- clusterProfiler::simplify(gsea)
```

```{r fig.height=10, fig.width=10}
p <- gsea |>
  enrichplot::pairwise_termsim() |>
  enrichplot::treeplot(
    showCategory = 40, nCluster = 12,
    offset = 20, offset_tiplab = 1,
    label_format_cladelab = 5, color = "NES",
    geneClusterPanel = "dotplot", nWords = 0) +
  ggplot2::scale_y_continuous(expand = ggplot2::expansion(mult = c(0, 0), add = c(6, 0))) +
  ggplot2::scale_color_gradient2(low = "blue", mid = "white", high = "red", name = "NES") +
  ggplot2::coord_cartesian()
p
```

从上面的 GO 词条来看，这确实像是发育程序。

### Sample loadings of NAM PCs

```{r}
sample_df <- as.data.frame(obj_mock@reductions$cna@feature.loadings[, 1:2])
sample_df$sample <- stringr::str_extract(rownames(sample_df), "\\dDPI-MOCK")

ggplot2::ggplot(sample_df, ggplot2::aes(NAMPC_1, NAMPC_2, color = sample)) +
  ggplot2::geom_point()
```

## 4 RNA 速率

```{r}
adata <- runScVelo(
  sce_mock,
  mode = "dynamical",
  use.dimred = "HARMONY",
  assay.X = "logcounts",
  scvelo.params = list(
    filter_and_normalize = list(
      min_shared_counts = 20L, n_top_genes = 2000L),
    moments = list(n_pcs = 30L, n_neighbors = 30L)
  )
)
```

```{r}
scv <- reticulate::import("scvelo")

adata$obsm$update(list(
  X_tsne = reducedDim(sce_mock, "TSNE"),
  X_umap = reducedDim(sce_mock, "UMAP"),
  X_phate = reducedDim(sce_mock, "PHATE")
))

adata$obs$cellType <- sce_mock$cluster_id
```

### 速率流线 {.tabset}

#### UMAP

```{python plot-stream-umap, fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata, basis="umap", color="cellType", figsize = (7, 7))
```

#### t-SNE

```{python plot-stream-tsne, fig.height=7, fig.width=7}
scv.pl.velocity_embedding_stream(
  r.adata, basis="tsne", color="cellType", figsize= (7, 7))
```

### 速率细胞 {.tabset}

#### UMAP

```{python plot-velo-umap, fig.height=12, fig.width=12}
scv.pl.velocity_embedding(
  r.adata, basis="umap", color="cellType", figsize=(12, 12),
  arrow_length=6, arrow_size=3, scale=2, dpi=300)
```

#### t-SNE

```{python plot-velo-tsne, fig.height=12, fig.width=12}
scv.pl.velocity_embedding(
  r.adata, basis="tsne", color="cellType", figsize=(12, 12),
  arrow_length=6, arrow_size=3, scale=2, dpi=300)
```

### 速度 {.tabset}

> The speed or rate of differentiation is given by the length of the velocity vector.

```{python}
kwargs=dict(cmap='coolwarm', size=10, perc=[5, 95], figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_length', basis="umap", **kwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_length', basis="tsne", **kwargs)
```

### 连贯性 {.tabset}

> The coherence of the vector field (i.e., how a velocity vector correlates with its neighboring velocities) provides a measure of confidence.

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_confidence', basis="umap", **kwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, c='velocity_confidence', basis="tsne", **kwargs)
```

### 速率图 {.tabset}

> We can visualize the velocity graph to portray all velocity-inferred cell-to-cell connections/transitions. It can be confined to high-probability transitions by setting a `threshold`.

```{python}
vgkwargs=dict(threshold=5, size=10, alpha=.2, color="cellType", figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.velocity_graph(r.adata, basis="umap", **vgkwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.velocity_graph(r.adata, basis="tsne", **vgkwargs)
```

### 速率拟时序 {.tabset}

> Finally, based on the velocity graph, a velocity pseudotime can be computed. After inferring a distribution over root cells from the graph, it measures the average number of steps it takes to reach a cell after walking along the graph starting from the root cells.
>
> Contrarily to diffusion pseudotime, it implicitly infers the root cells and is based on the directed velocity graph instead of the similarity-based diffusion kernel.

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(
  r.adata, color='velocity_pseudotime', cmap='gnuplot',
  basis='umap', figsize=(7, 7))
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(
  r.adata, color='velocity_pseudotime', cmap='gnuplot',
  basis='tsne', figsize=(7, 7))
```

### 隐时间 {.tabset}

> The dynamical model recovers the latent time of the underlying cellular processes. This latent time represents the cell's internal clock and approximates the real time experienced by cells as they differentiate, based only on its transcriptional dynamics.
>
> scVelo's latent time is based only on its transcriptional dynamics and represents the cell's internal clock. It captures aspects of the actual time better than similarity-based diffusion pseudo-time.

```{python}
ltkwargs=dict(color='latent_time', color_map='gnuplot', size=20, figsize=(7, 7))
```

#### UMAP

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, basis="umap", **ltkwargs)
```

#### t-SNE

```{python fig.height=7, fig.width=7}
scv.pl.scatter(r.adata, basis="tsne", **ltkwargs)
```

### PAGA 图 {.tabset}

> PAGA graph abstraction has benchmarked as top-performing method for trajectory inference. It provides a graph-like map of the data topology with weighted edges corresponding to the connectivity between two clusters. Here, PAGA is extended by velocity-inferred directionality.

```{python}
r.adata.uns['neighbors']['distances'] = r.adata.obsp['distances']
r.adata.uns['neighbors']['connectivities'] = r.adata.obsp['connectivities']

scv.tl.paga(r.adata, groups='cellType', threshold_root_end_prior=1)
```

#### UMAP

```{python fig.width=7, fig.height=7}
scv.pl.paga(r.adata, basis='umap', size=50, alpha=.1, legend_loc='on data',
            min_edge_width=2, node_size_scale=1.5, figsize=(7, 7))
```

#### t-SNE

```{python fig.width=7, fig.height=7}
scv.pl.paga(r.adata, basis='tsne', size=50, alpha=.1, legend_loc='on data',
            min_edge_width=2, node_size_scale=1.5, figsize=(7, 7))
```

#### PHATE

```{python fig.width=7, fig.height=7}
scv.pl.paga(r.adata, basis='phate', size=50, alpha=.1, legend_loc='on data',
            min_edge_width=2, node_size_scale=1.5, figsize=(7, 7))
```

```{r}
knitr::knit_exit()
```


